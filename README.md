# Вопросы
## Вопросы к 1 лабе:
Три принципа ООП. Пример.
- Инкапсуляция: Скрытие внутренней реализации объекта и предоставление доступа к данным через методы. Например, класс BankAccount может иметь закрытые поля для баланса и методы для внесения и снятия средств.
- Наследование: Возможность создавать новый класс на основе существующего. Например, класс Vehicle может быть базовым, а Car и Truck — производными классами.
- Полиморфизм: Возможность использовать один интерфейс для различных типов объектов. Например, метод draw() может быть реализован в классах Circle и Square, но вызывать его можно через ссылку типа Shape.
Классы и объекты. Свойства объектов. Пример.
- Класс: Шаблон для создания объектов. Например:
```      
class Car {
    String model;
    int year;
}
```
Объект: Конкретный экземпляр класса. 
```
    Car myCar = new Car();
    myCar.model = "Toyota";
    myCar.year = 2020;
```
Члены класса. Модификаторы объявления класса.
- Члены класса: Поля (свойства) и методы. 
- Модификаторы: public, private, protected, default. Например:
```
public class Example {
private int value; // поле доступно только внутри класса
}
```
Пакеты. 
- Пакеты группируют классы и интерфейсы. Например:
```
package com.example.utils;
```
Пространства имен
- Это способ организации классов и пакетов, чтобы избежать конфликтов имен. Например, два класса с одинаковым именем могут находиться в разных пакетах.
- Модуль компиляции — это набор классов, которые могут быть скомпилированы вместе. В Java это обычно один .java файл.
- Поля — это переменные, объявленные в классе. Например:
```
class Person {
String name;
int age;
}
```
+ Методы и метод main
- Методы: Функции, определенные внутри класса.
- Метод main: Точка входа в программу:
```
public static void main(String[] args) {
// код программы
}
```
+ Модификаторы доступа 
- Определяют уровень доступа к членам класса:
- public: доступен отовсюду.
- private: доступен только внутри класса.
- protected: доступен в классе и его подклассах.
+ Создание объектов и конструкторы
- Объекты создаются с помощью ключевого слова new. Конструктор — это специальный метод для инициализации объекта:
```
class Dog {
String name;

  Dog(String name) {
      this.name = name;
  }
}

Dog myDog = new Dog("Buddy");
```
+ Блоки инициализации, статическая инициализация
- Блоки инициализации: Код, выполняемый при создании объекта.
- Статическая инициализация: Выполняется при загрузке класса.
+ Простейшие типы и массивы
- Простые типы — это базовые типы данных (int, char, boolean). Массивы хранят несколько значений одного типа:
```
int[] numbers = {1, 2, 3};
```
+ Исключения
- Родительский класс исключений: Throwable.
- Выбрасывание исключений: Использование ключевого слова throw.
- Объявляемые и необъявляемые исключения: Объявляемые (checked) требуют обработки, необъявляемые (unchecked) — нет. Пример:
```
try {
throw new Exception("Error");
} catch (Exception e) {
e.printStackTrace();
}
``` 
+ Синхронные и асинхронные исключения
- Синхронные: Происходят во время выполнения программы (например, деление на ноль).
- Асинхронные: Происходят вне контекста текущего потока (например, прерывание).

+ Предложение throws
- Используется для указания, что метод может выбросить исключение:
  ```
  void myMethod() throws IOException {
  // код
  }
  ```
+ try, catch и finally
- Используются для обработки исключений:
```
try {
// код, который может вызвать исключение
} catch (Exception e) {
// обработка исключения
} finally {
// код, который выполнится в любом случае
}
```
+ Интерфейсы и модификаторы в объявлениях интерфейсов
- Интерфейсы определяют методы без реализации. Модификаторы: public, default, static.
Пример:
```
interface Animal {
void makeSound();
}
```
+ Объявление интерфейса, константы и методы в интерфейсах
- Интерфейсы могут содержать константы (по умолчанию public static final) и абстрактные методы (по умолчанию public):
```
interface Vehicle {
int MAX_SPEED = 120; // константа
void drive(); // метод без реализации
}
```
+ Расширение интерфейсов, наследование и сокрытие констант
- Интерфейсы могут наследоваться:
```
interface ElectricVehicle extends Vehicle {
void charge();
}
```
- Сокрытие констант происходит при наследовании интерфейсов с одинаковыми константами.
+ Наследование, переопределение и перегрузка методов
- Наследование: Подкласс наследует члены родительского класса.
- Переопределение: Изменение реализации метода в подклассе.
- Перегрузка: Создание нескольких методов с одним именем, но с разными параметрами.
+ Пустые интерфейсы
- Интерфейсы без методов могут использоваться для маркировки классов:
```
interface Marker {}
```
+ Отличия абстрактного класса от интерфейса
- Абстрактный класс может содержать реализацию методов, а интерфейс — нет.
- Класс может наследовать только один абстрактный класс, но может реализовывать несколько интерфейсов.
## Вопросы ко 2 лабе:
+ Потоки данных. Байтовые потоки. Базовые абстрактные классы байтовых потоков.
  - Потоки данных — это абстракция для работы с последовательными данными, позволяющая читать и записывать данные.
  - Байтовые потоки работают с бинарными данными. Они представляют собой последовательность байтов.
  - Базовые абстрактные классы байтовых потоков 
    - *InputStream*: абстрактный класс для чтения байтов. 
    - *OutputStream*: абстрактный класс для записи байтов.
+ Символьные потоки. Базовые абстрактные классы символьных потоков.
  - Символьные потоки предназначены для работы с текстовыми данными (символами).
  - Базовые абстрактные классы символьных потоков 
    - Reader: абстрактный класс для чтения символов. 
    - Writer: абстрактный класс для записи символов.
+ Стандартные потоки. 
  - Стандартные потоки включают:
    - System.in: стандартный вход (InputStream). 
    - System.out: стандартный выход (OutputStream). 
    - System.err: стандартный поток ошибок (OutputStream).
+ InputStreamReader и OutputStreamWriter.
  - InputStreamReader: преобразует байтовый поток (InputStream) в символьный (Reader). 
  - OutputStreamWriter: преобразует символьный поток (Writer) в байтовый (OutputStream).
+ Примеры байтовых и символьных классов потоков. 
+ Сериализация объектов. Подготовка классов к сериализации. 
+ Порядок сериализации и десериализации. Настройка механизма сериализации. 
+ Контроль версий объектов.