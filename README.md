# Вопросы

## Вопросы к 1 лабе:
+ Три принципа ООП. Пример.
  - Инкапсуляция: Скрытие внутренней реализации объекта и предоставление доступа к данным через методы. Например, класс BankAccount может иметь закрытые поля для баланса и методы для внесения и снятия средств.
  - Наследование: Возможность создавать новый класс на основе существующего. Например, класс Vehicle может быть базовым, а Car и Truck — производными классами.
  - Полиморфизм: Возможность использовать один интерфейс для различных типов объектов. Например, метод draw() может быть реализован в классах Circle и Square, но вызывать его можно через ссылку типа Shape.
+ Классы и объекты. Свойства объектов. Пример.
  - Класс: Шаблон для создания объектов. Например:
    ```      
        class Car {
            String model;
            int year;
        }
      ```
    Объект: Конкретный экземпляр класса. 
    ```
        Car myCar = new Car();
        myCar.model = "Toyota";
        myCar.year = 2020;
    ```
+ Члены класса. Модификаторы объявления класса.
  - Члены класса: Поля (свойства) и методы. 
  - Модификаторы: public, private, protected, default. Например:
    ```
    public class Example {
    private int value; // поле доступно только внутри класса
    }
    ```
+ Пакеты. 
  - Пакеты группируют классы и интерфейсы. Например:
    ```
    package com.example.utils;
    ```
+ Пространства имен
  - Это способ организации классов и пакетов, чтобы избежать конфликтов имен. Например, два класса с одинаковым именем могут находиться в разных пакетах.
+ Модуль компиляции
  - Модуль компиляции — это набор классов, которые могут быть скомпилированы вместе. В Java это обычно один .java файл.
+ Поля 
  - Поля — это переменные, объявленные в классе. Например:
    ```
    class Person {
    String name;
    int age;
    }
    ```
+ Методы и метод main
  - Методы: Функции, определенные внутри класса.
  - Метод main: Точка входа в программу:
    ```
    public static void main(String[] args) {
    // код программы
    }
    ```
+ Модификаторы доступа 
  - Определяют уровень доступа к членам класса:
    - public: доступен отовсюду.
    - private: доступен только внутри класса.
    - protected: доступен в классе и его подклассах.
+ Создание объектов и конструкторы
  - Объекты создаются с помощью ключевого слова new. Конструктор — это специальный метод для инициализации объекта:
  ```
  class Dog {
  String name;

      Dog(String name) {
          this.name = name;
      }
  }

    Dog myDog = new Dog("Buddy");
  ```
+ Блоки инициализации, статическая инициализация
  - Блоки инициализации: Код, выполняемый при создании объекта.
  - Статическая инициализация: Выполняется при загрузке класса.
+ Простейшие типы и массивы
  - Простые типы — это базовые типы данных (int, char, boolean). Массивы хранят несколько значений одного типа:
  ```
  int[] numbers = {1, 2, 3};
  ```
+ Исключения
  - Родительский класс исключений: Throwable.
  - Выбрасывание исключений: Использование ключевого слова throw.
  - Объявляемые и необъявляемые исключения: Объявляемые (checked) требуют обработки, необъявляемые (unchecked) — нет. Пример:
    ```
    try {
    throw new Exception("Error");
    } catch (Exception e) {
    e.printStackTrace();
    }
    ``` 
+ Синхронные и асинхронные исключения
  - Синхронные: Происходят во время выполнения программы (например, деление на ноль).
  - Асинхронные: Происходят вне контекста текущего потока (например, прерывание).

+ Предложение throws
  - Используется для указания, что метод может выбросить исключение:
      ```
      void myMethod() throws IOException {
      // код
      }
      ```
+ try, catch и finally
  - Используются для обработки исключений:
  ```
  try {
  // код, который может вызвать исключение
  } catch (Exception e) {
  // обработка исключения
  } finally {
  // код, который выполнится в любом случае
  }
  ```
+ Интерфейсы и модификаторы в объявлениях интерфейсов
  - Интерфейсы определяют методы без реализации. Модификаторы: public, default, static.
  Пример:
  ```
  interface Animal {
  void makeSound();
  }
  ```
+ Объявление интерфейса, константы и методы в интерфейсах
  - Интерфейсы могут содержать константы (по умолчанию public static final) и абстрактные методы (по умолчанию public):
  ```
  interface Vehicle {
  int MAX_SPEED = 120; // константа
  void drive(); // метод без реализации
  }
  ```
+ Расширение интерфейсов, наследование и сокрытие констант
  - Интерфейсы могут наследоваться:
  ```
  interface ElectricVehicle extends Vehicle {
  void charge();
  }
  ```
  - Сокрытие констант происходит при наследовании интерфейсов с одинаковыми константами.
+ Наследование, переопределение и перегрузка методов
  - Наследование: Подкласс наследует члены родительского класса.
  - Переопределение: Изменение реализации метода в подклассе.
  - Перегрузка: Создание нескольких методов с одним именем, но с разными параметрами.
+ Пустые интерфейсы
  - Интерфейсы без методов могут использоваться для маркировки классов:
  ```
  interface Marker {}
  ```
+ Отличия абстрактного класса от интерфейса
  - Абстрактный класс может содержать реализацию методов, а интерфейс — нет.
  - Класс может наследовать только один абстрактный класс, но может реализовывать несколько интерфейсов.

## Вопросы к 4 лабе:
1. Модель OSI.
> В течение последних нескольких десятилетий размеры и количество сетей значительно выросли. В 80-х годах имелось множество типов сетей. И практически каждая из них была построена на своем типе оборудования и программного обеспечения, зачастую не совместимых между собой. Это приводило к значительным трудностям при попытке соединить несколько различных типов сетей (например, различный тип адресации делал эти попытки практически безнадежными). Эта проблема была рассмотрена Всемирной Организацией по Стандартам (International Organization for Standardization, ISO), и в результате в 1984 г. была разработана модель OSI - модель взаимодействия открытых систем (Open Systems Interconnected). Эта модель состоит из семи уровней:
> - **Физический уровень** Этот уровень описывает среду передачи данных. Стандартизируются физические устройства, отвечающие за передачу электрических сигналов (разъемы, кабеля и т.д.) и правила формирования этих сигналов. Физический уровень также отвечает за преобразование сигналов между различными средами передачи данных. Например, при необходимости соединить сегмент сети, построенной на оптоволокне и витой паре применяют т.н. конверторы (в данном случае они преобразуют световой импульс в электрический).
> - **Уровень соединения** (канальный уровень). На физическом уровне пересылаются просто набор сигналов - битов. При этом не проверяется, что несколько компьютеров могут в одну среду передачи данных одновременно передавать информацию в виде битов. Поэтому одной из задач канального уровня является проверка доступности среды передачи. Также этот уровень отвечает за доставку между источником и адресатом в пределах сети с одной топологией.
> - **Сетевой уровень** Одним из ограничений канального уровня является использование “плоской” модель адресации. Протокол, который поддерживается сетевым уровнем, использует иерархическую структуру для уникальной идентификации компьютеров. Для примера представим себе телефонную сеть. Она также имеет иерархическую адресацию. Например, в номере +7-095-101-12-34 первая цифра обозначает код страны, далее идет код области/города(095), а затем указывается сам телефон (101-12-34). Последний номер также является составным. 101 - это код станции, куда подключен телефон, а 12-34 определяет местоположение телефона. Благодаря такой иерархической структуре мы можем определить расположение требуемого абонента с наименьшими затратами. Иерархическая адресация для сети также должна позволять передавать данные между разрозненными и удаленными сетями.
> - **Транспортный уровень** Рассмотрим TCP/IP протокол транспортного уровня модели OSI. TCP/IP имеет два протокола - TCP и UDP. Transmission Control Protocol TCP – основанный на соединениях протокол, обеспечивающий надежную передачу данных между двумя компьютерами с сохранением порядка данных. Используется в HTTP, FTP. User Datagram Protocol UDP – не основанный на соединениях протокол, реализующий пересылку независимых пакетов данных, называемых дейтаграммами, от одного компьютера к другому без гарантии их доставки).
> - **Сеансовый уровень** Обеспечивает установку, контроль и окончание сессии между приложениями. Уровень сессий координирует приложения, когда они взаимодействуют между двумя хостами.
> - **Уровень представления** Уровень представлений отвечает за представление данных в форме, понятной получателю. Например, для представления данных могут быть использованы такие кодировки, как Extended Binary Coded Decimal Interchange Code (EBCDIC) или American Standard Code for Information Interchange (ASCII). Если компьютеры, между которыми установлено сетевое соединение, используют различные протоколы, то presentation layer обеспечивает их корректное взаимодействие. Уровень представлений также отвечает за шифрацию и сжатие данных.
> - **Прикладной уровень** Уровень приложений определяет, какие ресурсы существуют для связи между хостами.
>
> Каждый уровень взаимодействует только с соседними уровнями, протокол взаимодействия стандартизован. Это позволяет использовать реализации сетевого и программного обеспечения от разных производителей в различных комбинациях. Например, протоколы высокого уровня (HTTP, FTP) не зависят от физических параметров используемой сети.
> Большинство сетевых приложений можно классифицировать как клиент-серверные приложения.
2. Модель «Клиент-сервер». Понятие порта. Абстракция сокета.
> **Модель «Клиент-сервер»**
> Каждая из сторон виртуального соединения называется «сокет» (socket). Приложение-сервер инициализируется при запуске и далее бездействует, ожидая поступления запроса от клиента. Типы приложений-серверов - Сервер последовательной обработки запросов и Сервер параллельной обработки запросов. Процесс-клиент посылает запрос на установление соединения с сервером, требуя выполнить для него определенную функцию.

> **Понятие порта**
> Компьютер (обычно) имеет только одно физическое соединение с сетью. Соединение описывается, например, IP-адресом (32 бита на сегодняшний день). Как различать информацию для различных приложений? Сокет привязывается к порту. Порт описывается 16-битным числом. Порты 0-1023 зарезервированы

> **Абстракция сокета**
> Сетевое соединение –  это процесс передачи данных по сети между двумя компьютерами или процессами. Сокет – конечный пункт передачи данных. Для программ сокет – одно из окончаний сетевого соединения. Для установления соединения каждая из сетевых программ должна иметь свой собственный сокет. Связь между двумя сокетами может быть ориентированной или не ориентированной на соединение. Сокет связан с номером порта.

3. Пакет java.net. Класс Socket. Порядок работы с сокетом клиента.
> **Пакет java.net**
> - Адресация.
> - Установление TCP-соединения.
> - Передача/прием дейтаграмм через UDP.
> - Обнаружение/идентификация сетевых ресурсов.
> - Безопасность: авторизация / права доступа.
>
> Класс InetAddress является интернет-адресом, или  IP. Экземпляры этого класса создаются не с помощью конструкторов, а с помощью статических методов:
> - InetAddress getLocalHost() - возвращает IP-адрес машины, на которой исполняется Java-программа.
> - InetAddress getByName(String name) - возвращает адрес сервера, чье имя передается в качестве параметра. Это может быть как DNS-имя, так и числовой IP, записанный в виде текста, например, "67.11.12.101".
> - InetAddress[] getAllByName(String name) - определяет все IP-адреса указанного сервера.
>
> Класс Inet4Address служит для описания адреса, состоящего из 4 байтов, с помощью класса Inet6Address описывается адрес, состоящий из 16 байтов. Начиная с JDK 1.4. существует класс InetSocketAddress(String hostname, int port), который создаёт объект адреса для указанного узла и порта.

> **Класс Socket**
> - Реализует клиентский сокет и его функции
> - Конструкторы
    >   - Socket()
>   - Socket(InetAddress address, int port)
>   - Socket(InetAddress address, int port, InetAddress localAddr, int localPort)
>   - Socket(String host, int port)
>   - Socket(String host, int port, InetAddress localAddr, int localPort)
> - Методы
    >   - void close() – закрывает используемый сокет.
>   - InetAddress getLocalAddress()
>   - InputStream getInputStream() – возвращает поток, позволяющий читать данные, переданные по сети.
>   - OutputStream getOutputStream() - возвращает поток, позволяющий передавать данные по сети.
>   - static void setSocketImplFactory(SocketImplFactory fac)
>   - И прочие…

> **Порядок работы с сокетом клиента**
> - Открытие сокета.
> - Открытие потока ввода и/или потока вывода для сокета.
> - Чтение и запись в потоки согласно установленному протоколу общения с сервером.
> - Закрытие потоков ввода-вывода.
> - Закрытие сокета.
>
> For example:
> ```
> import java.io.*;
> import java.net.*;
>
> public class EchoClient {
> public static void main(String[] args) throws IOException {
> Socket echoSocket = null;
> PrintWriter out = null;
> BufferedReader in = null;
> try {
> echoSocket = new Socket("taranis", 7);
> out = new PrintWriter(echoSocket.getOutputStream(), true);
> in = new BufferedReader(new InputStreamReader(
> echoSocket.getInputStream()));        
> } catch (UnknownHostException e) {
> System.err.println("Don't know about host: taranis.");
> System.exit(1);
> } catch (IOException e) {
> System.err.println("Couldn't get I/O for the connection to:" + "taranis.");
> System.exit(1);
> }
> BufferedReader stdIn = new BufferedReader(new InputStreamReader(System.in));
> String userInput;
>
>    while ((userInput = stdIn.readLine()) != null) {
>      out.println(userInput);
>      System.out.println("echo: " + in.readLine());
>    }
>
>    out.close();
>    in.close();
>    stdIn.close();
>    echoSocket.close();
>   }
> }
> ```

4. Класс ServerSocket. Сервер параллельной обработки запросов.
> **Класс ServerSocket**
> - Реализует серверный сокет и его функции
> - Конструкторы
    >   - ServerSocket()
>   - ServerSocket(int port)
>   - ServerSocket(int port, int backlog)
> - Методы
    >   - void close() – закрывает используемый сокет
>   - Socket accept() – приостагавливает выполнение программы и ожидает обращения клиента
>   - void bind(SocketAddress endpoint)
>   - И прочие…
>
> For example:
> ```
> try {
> serverSocket = new ServerSocket(4444); 
> } catch (IOException e) {
> System.out.println("Could not listen on port: 4444");
> System.exit(-1); 
> } 
> Socket clientSocket = null; 
> try {
> clientSocket = serverSocket.accept(); 
> } catch (IOException e) {
> System.out.println("Accept failed: 4444"); 
> System.exit(-1); 
> }
> ```

> **Сервер параллельной обработки запросов**
>
> ![image](first_labs/src/main/resources/parallel-processing.png)
5. Дейтаграммы.
> Дейтаграмма – независимое, самодостаточное сообщение, посылаемое по сети, чья доставка, время (порядок) доставки и содержимое не гарантируются. Могут использоваться как для адресной, так и для широковещательной рассылки.
> **DatagramPacket**
> - Экземпляры являются прототипами дейтаграмм-сообщений
> - Конструкторы
> - DatagramPacket(byte[] buf, int offset, int length, InetAddress address, int port)
> - И прочие…
> - Методы
    >   - byte[] getData()
>   - int getLength()
>   - int getOffset()
>   - SocketAddress getSocketAddress()
>   - void setSocketAddress(SocketAddress address)
>   - void setData(byte[] buf, int offset, int length)
>   - И прочие…
>
> **DatagramSocket**
> - Экземпляры являются не ориентированными на соединение сокетами
> - Конструкторы
    >   - DatagramSocket()
>   - DatagramSocket(int port, InetAddress laddr)
>   - И другие…
> - Методы
    >   - void bind(SocketAddress addr)
>   - void close()
>   - void connect(InetAddress address, int port)
>   - void send(DatagramPacket p)
>   - void receive(DatagramPacket p)
>   - И другие…

6. Uniform Resource Locator.
> - URL – адрес ресурса в Интернет
> - Имя протокола
> - Протокол, используемый для связи
> - Имя хоста
> - Имя компьютера, на котором расположен ресурс
> - Имя файла
> - Путь к файлу на компьютере
> - Номер порта
> - Номер порта для соединения (необязателен, если порт не указан, то используется значение по умолчанию для указанного протокола)
> - Ссылка
> - Ссылка на именованный якорь (необязательна)
> - Может быть абсолютным и относительным
>
> URL gamelan = new URL("http", "www.gamelan.com", 80, "pages/Gamelan.network.html");
> Для простого извлечения содержимого заданного ресурса достаточно использовать метод openStream() класса URL. Этот метод возвращает объект InputStream. Прямое чтение из URL:
> ```
> import java.net.*;
> import java.io.*;
> 
> public class URLReader {
> public static void main(String[] args) throws Exception {
> URL yahoo = new URL("http://www.yahoo.com/");
> BufferedReader in = new BufferedReader(
> new InputStreamReader(
> yahoo.openStream()));
> String inputLine;
> while ((inputLine = in.readLine()) != null)
> System.out.println(inputLine);
> in.close();
>   }
> }
> ```
> Для получения дополнительной информации о ресурсе потребуется использовать класс URLConnection, который предоставляет гораздо больше средств управления доступом к Web-ресурсам. Для получения объекта URLConnection нужно вызвать метод openConnection() класса URL.  Чтение из URL-соединения:
> ```
> import java.net.*;
> import java.io.*;
> public class URLConnectionReader {
> public static void main(String[] args) throws Exception {
> URL yahoo = new URL("http://www.yahoo.com/");
> URLConnection yc = yahoo.openConnection();
> BufferedReader in = new BufferedReader(
> new InputStreamReader(
> yc.getInputStream()));
> String inputLine;
> while ((inputLine = in.readLine()) != null)
> System.out.println(inputLine);
> in.close();
>   }
> }
>```
> Существует несколько методов класса URLConnection, предназаначеннных для указания свойств соединения ещё до подключения к серверу. По умолчанию соединение получает входной поток для чтения, но не получает выходной поток для записи. Для получения выходного потока нужно вызвать метод setDoOutput(true). Запись в URL-соединение:
> ```
> import java.io.*;
> import java.net.*;
> public class Reverse {
> public static void main(String[] args) throws Exception {
> if (args.length != 1) {
> System.err.println("Usage:  java Reverse" + "string_to_reverse");
> System.exit(1);
> }
> String stringToReverse = URLEncoder.encode(args[0], “US-ASCII”);
> URL url = new URL("http://java.sun.com/cgi-bin/backwards");
> URLConnection connection = url.openConnection();
> connection.setDoOutput(true);
> PrintWriter out = new PrintWriter(
> connection.getOutputStream());
> out.println("string=" + stringToReverse);
> out.close();
> BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));
> String inputLine;
> while ((inputLine = in.readLine()) != null)
> System.out.println(inputLine);	
> in.close();
>   }
> }
> ```

## Вопросы к 5 лабе:

1. Класс Graphics. Работа с цветом. Работа со шрифтами.

> java.awt.Graphics - базовый класс, предназначенный для рисования в контекстах компонентов, в изображениях в памяти и
> т.д.
> - void drawArc(int x, int y, int width, int height, int startAngle, int arcAngle) - Этот метод вычерчивает (fillArc
    заполняет) дугу, ограниченную прямоугольником (x,y,width, height), начинающуюся с угла startAngle и имеющую угловой
    размер arcAngle. Ноль градусов соответствует положению часовой стрелки на 3 часа, угол отсчитывается против часовой
    стрелки (например, 90 градусов соответствуют 12 часам, 180 - 9 часам, и так далее).
> - void drawString(String str, int x, int y) - Этот метод выводит строку с использованием текущих шрифта и цвета. Точка
    с координатами (х,у) соответствует левой границе базовой линии символов, а не левому верхнему углу, как это принято
    в других методах рисования. Базовая линия (baseline) - линия, по которой выравниваются нижние границы символов.
> - и т.д.

> **Работа с цветом**
>
> Класс java.awt.Color.
> - Можно использовать константы класса (Color.BLUE, Color.RED) для задания какого-либо из общеупотребительных цветов (
    blue,red).
> - Для создания нового цвета можно использовать один из описанных ниже конструкторов:
> - Color(int, int, int) - параметрами для этого конструктора являются три целых числа в диапазоне от 0 до 255 для
    красного, зеленого и голубого компонентов цвета.
> - Color(int) - у этого конструктора - один целочисленный аргумент, в котором в упакованном виде заданы красный,
    зеленый и голубой компоненты цвета. Красный занимает биты 16-23, зеленый - 8-15, голубой - 0-7.
> - Color(float, float, float) - последний из конструкторов цвета, принимает в качестве параметров три значения типа
    float (в диапазоне от 0.0 до 1.0) для красного, зеленого и голубого базовых цветов.
> - Методы получения параметров цвета getRed(), getGreen(), getBlue() - каждый из этих методов возвращает в младших
    восьми битах результата значение соответствующего базового компонента цвета.

> **Работа со шрифтами**
>
> Класс java.awt.Font
> - Константы
> - Конструкторы
>
> Font(String name, int style, int size) - создает новый шрифт с указанным именем, стилем и размером. Имена шрифтов:
> Dialog, Helvetica, TimesRoman, Courier и Symbol. Для указания стиля шрифта внутри данного семейства предусмотрены три
> статические переменные. - Font.PLAIN, Font.BOLD и Font.ITALIC, что соответствует обычному стилю, курсиву и
> полужирному.
> - Методы модификации и получения параметров шрифта (getSize - метод возвращает целое число, представляющее собой
    размер шрифта, isBold, isItalic, isPlain - методы возвращают true в том случае, если стиль шрифта - полужирный (
    bold), курсив (italic) или обычный (plain), соответственно).
>
> Класс java.awt.FontMetrics
> - Содержит методы определения геометрических характеристик шрифтов (getAscent, getDescent, getHeight - эти методы
    возвращают подъем, снижение и ширину шрифта. Сумма подъема и снижения дают полную высоту шрифта. Высота шрифта - это
    не просто расстояние от самой нижней точки букв g и у до самой верхней точки заглавной буквы Т и символов вроде
    скобок. Высота включает подчеркивания и т.п.).

2. Особенности AWT. Менеджеры компоновки.

> - Компоненты являются компонентами ОС
    >   - большое количество native-кода
>   - отображение изменяется при смене ОС
> - Применение:
    >   - в апплетах
>   - в оконных приложениях
> - Абстрактный класс Component определяет базовую функциональность всех компонентов. Это класс, который инкапсулирует
    все атрибуты визуального интерфейса - обработка ввода с клавиатуры, управление фокусом, взаимодействие с мышью,
    уведомление о входе/выходе из окна, изменения размеров и положения окон, прорисовка своего собственного графического
    представления, сохранение текущего текстового шрифта, цветов фона и переднего плана (более 100 методов).

3. Модель делегирования обработки событий. Событие. Источник. Слушатель. Пример.

> **Модель делегирования обработки событий**
> - Источник генерирует событие и посылает его одному или нескольким слушателям.
> - Слушатель просто ждет поступления события.
> - Получив событие, слушатель обрабатывает его и затем возвращает управление.
> - Слушатели должны зарегистрироваться у источника – события посылаются только зарегистрировавшимся слушателям.
> - Логика кода, обрабатывающего события, отделена от логики интерфейса, генерирующего события.

> **Событие**
>
> Событие – это объект, описывающий изменение состояния источника. В модели обработки событий Java разным типам событий
> соответствуют различные классы Java. Каждое событие является подклассом класса java.util.EventObject. События пакета
> AWT
> являются подклассом java.awt.AWTEvent. Для удобства события различных типов пакета AWT (например, MouseEvent или
> АсtionEvent) помещены в новый пакет java.awt.event. Для каждого события существует порождающий его объект, который
> можно
> получить с помощью метода public Object getSource(), и каждому событию пакета AWT соответствует определенный
> идентификатор, который позволяет получить метод public int getID(). Это значение используется для того, чтобы отличать
> события различных типов, которые могут описываться одним и тем же классом событий. Например, для класса FocusEvent
> возможны два типа событий: FocusEvent.FOCUS_GAINED и FocusEvent.FOCUS_LOST

> **Источник**
> - Источник – объект, генерирующий события. Источник может генерировать несколько типов событий.
> - Регистрация слушателя:   
    public void addTypeListener(TypeListener el) throws java.util.TooManyListenersException   
    public void removeTypeListener(TypeListener el)

> **Слушатель**
> - Слушатель – объект, получающий уведомление о событии.
> - Может быть зарегистрирован одним или несколькими источниками.
> - Должен реализовывать методы для приема и обработки уведомлений.
> - Существует набор интерфейсов **TypeListener**, описывающих методы обработки событий. Например, объекты слушателей
    событий ActionEvent должны реализовывать интерфейс ActionListener. В пакете java.awt.event содержатся интерфейсы
    слушателей для каждого из определенных в нем типов событий (например, для событий MouseEvent здесь определено два
    интерфейса слушателей: MouseListener и MouseMotionListener). Все интерфейсы слушателей событий являются расширениями
    интерфейса java.util.EventListener. В этом интерфейсе не определяется ни один из методов, но он играет роль
    интерфейса-метки, в котором однозначно определены все слушатели событий как таковые.

4. Классы-адаптеры.

> Для каждого интерфейса слушателей событий, содержащего несколько методов, в пакете java.awt.event определен простой
> класс-адаптер, который обеспечивает пустое тело для каждого из методов соответствующего интерфейса. Когда нужен только
> один или два таких метода, иногда проще получить подкласс класса-адаптера, чем реализовать интерфейс самостоятельно. При
> получении подкласса адаптера требуется лишь переопределить те методы, которые нужны, а при прямой реализации интерфейса
> необходимо определить все методы, в том числе и ненужные в данной программе. Заранее определенные классы-адаптеры
> называются так же, как и интерфейсы, которые они реализуют, но в этих названиях Listener заменяется на Adapter:
> MouseAdapter, WindowAdapter и т.д.

5. Статические вложенные классы. Вложенные интерфейсы.

> **Статический вложенный класс** - это простейшая форма вложенного класса, в его объявлении присутствует служебное
> слово static. Если класс вложен в интерфейс, он получает статус статического по умолчанию, и модификатор static, в
> соответствии с принятым соглашением, опускается. Статический вложенный класс может наследовать другие классы,
> реализовывать любые интерфейсы и сам по себе служить объектом расширения для любого класса, обладающего необходимыми
> правами доступа. В объявлении статического вложенного класса, как и обычного класса, разрешается применять модификаторы
> final и abstract. Статические классы, вложенные в другой класс, являются членами последнего и допускают применение любых
> модификаторов доступа.  
> Пример 26.
> ```
> abstract public class ClassA {
> protected static class ClassB {
> ...
>   }
> }
> ```
> **Вложенные интерфейсы** всегда статичны, хотя соответствующий модификатор, static, в соответствии с принятым
> соглашением, принято опускать. Доступ определяется доступом внешнего класса или интерфейса.   
> Пример 27.
> ```
> public class ClassA {
> protected interface InterfaceB {
>       ...
>   }
> }
> ```

6. Нестатические вложенные классы. Локальные классы. Анонимные классы.

> **Нестатические вложенные классы** называются внутренними классами. Объект внутреннего класса всегда ассоциируется с
> т.н. внешним объектом (с соответствующим объектом внешнего класса). Элементы внутреннего класса имеют доступ к полям и
> методам внешнего объекта. Внутренние классы не способны содержать статические члены, кроме полей вида final static,
> инициализируемых константами или постоянными выражениями. Внутренние классы, как и обычные, способны расширять любые
> другие классы, реализовывать интерфейсы и выступать в роли объектов наследования. Вполне допустимо использовать в
> объявлении внутреннего класса модификаторы final и abstract.  
> Пример 28.
> ```
> abstract public class ClassA {
> private class ClassB {
>       ...
>   }
> }
> ```
> **Локальные классы**  
> Разрешается объявлять вложенные классы внутри блоков кода, таких как тело метода, конструктор или блок инициализации.
> Подобный **локальный** внутренний **класс** не является членом класса, к которому относится блок, а принадлежит самому
> блоку – точно так же, как обычная локальная переменная. Такие классы недоступны за пределами внешнего класса, т.к. не
> сущестует способов обращения к ним, но их экземпляры – это обычные объекты, которые позволяется передавать в качестве
> аргументов или возвращать из методов. Единственный модификатор, который допускается применять в объявлении локального
> класса, - это final (модификаторы доступа запрещены). Экземпляры имеют доступ не только к полям и методам внешнего
> объекта, но и к локальным переменным. Однако такие переменные должны быть объявлены как final.   
> Пример 29.
> ```
> public class ClassA {
> public Iterator iterator() {
> class Iter implements Iterator {
> ...
> }
> ...
> return new Iter();
> }
> ```
> **Анонимные классы**
> Анонимные классы описываются непосредственно в выражении new и служат его частью. Тип, указанный после new, является базовым для объявляемого анонимного класса. Могут расширять один класс или реализовывать один интерфейс. Явно писать implements или extends нельзя. Не могут иметь конструкторов, так как имя конструктора должно совпадать с именем класса, а в данном случае класс не имеет имени. Параметры, необходимые для создания объекта, передаются конструктору суперкласса.
> Пример 30.
> ```
> import java.awt.*;
> import java.applet.*;
>
> public class MyApplet extends Applet {
> ...
> public void init() {
> Button btn = new Button(“?”);
> add(btn);
> btn.addActionListener(new ActionListener() {
> public void actionPerformed(ActionEvent e) {
> ((Button)e.getSource()).setLabel(“!”);
>           }
>       });
>   }
> }
> ```
7. Проблемы AWT. Особенности Swing. Look And Feel.
> **Проблемы AWT**:
> - Сходные элементы в различных ОС могут иметь некоторые различия (например, меню, панели прокрутки).
> - ОС часто имеют элементы GUI, отсутствующие в других ОС (некоторые графические среды программирования, например, X11/Motif, не имеют такого богатого набора компонентов пользовательского интерфейса, как ОС Windows или Macintosh).
> - Использование native-методов в AWT приводит к возникновению ошибок на конкретных платформах (на разных платформах возникали разные ошибки, приходилось тестировать каждое приложение на каждой платформе).

> **Особенности Swing**
> - Элементы GUI (меню, кнопки) отрисовываются в пустых окнах.
> - «Нативные» функции используются только для вывода окна, отрисовки и получения информации о действиях пользователя.
> - Обладает свойством «легковесности» (lightweight).
> - Набор элементов GUI более широк, чем в AWT, и может быть еще расширен.
> - Сильная привязка к «нативным» методам отсутствует, что снижает вероятность возникновения ошибок.
> - Отображение на различных платформах единообразно.

> **Look And Feel**   
> Программисты, использующие Swing, могут придать своей программе внешний вид в заданном стиле. Программе можно придать различный вид, изменив «стиль» отрисовки компонентов. Есть разработанные «стили» для базовых платформ. Существует возможность создания собственных «стилей». Sun разработала независимый от платформы стиль, названный Metal, который прозвали стилем Java. На рисунках 12-14 показано, как выглядит одна и та же программа при использовании различных стилей.
> Внешний вид программы может изменяться во время исполнения. Перерисовка должна вызываться принудительно.

8. Создание оконных приложений. Отрисовка компонентов.
> **Создание оконных приложений**
> - Используется класс JFrame.
> - Содержимое окна находится на панели, ссылку на которую можно получить вызовом метода getContentPane().
> - Параметрами окна можно управлять.
    > Пример 31.
> ```
> import java.awt.*;
> import javax.swing.*;
> 
> public class CenteredFrameTest {
> public static void main(String[] args) {
> CenteredFrame frame = new CenteredFrame();
> frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
> frame.setVisible(true);
> }
> }
> class CenteredFrame extends JFrame {
> public CenteredFrame() {
> Toolkit kit = Toolkit.getDefaultToolkit();
> Dimension screenSize = kit.getScreenSize();
> int screenHeight = screenSize.height;
> int screenWidth = screenSize.width;
> setSize(screenWidth / 2, screenHeight / 2);
> setLocation(screenWidth / 4, screenHeight / 4);
> Image img = kit.getImage("icon.gif");
> setIconImage(img);     setTitle("CenteredFrame");
> }
> }
> ```
> Комментарий к примеру 31.
> Определяем, что должно произойти, если пользователь закроет фрейм. В данном случае программа должна завершить свою работу. Для этого используется строка кода
>
> frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
>
> Если бы в программе использовалось несколько фреймов, завершать работу только по тому, что пользователь закрыл один из них, было бы необязательно. По умолчанию закрытый фрейм исчезает с экрана, а программа продолжает работу.
> Простое создание фрейма не приводит к его автоматическому появлению на экране. В начале своего существования все  фреймы невидимы. Это дает возможность добавлять к фрейму компоненты еще до того, как он впервые появится на экране. Чтобы показать фрейм на экране, вызывается метод setVisible().
> Если размер не задан явно, все фреймы по умолчанию имеют размер 0х0 пикселей. В профессиональных приложениях нужно сначала проверить разрешающую способность экрана и написать код, изменяющий размер фрейма в соответствии с полученной величиной: окно, которое прекрасно смотрится на экране портативного компьютера, на экране дисплея с большой разрешающей способностью будет выглядеть как почтовая марка. Для того, чтобы определить размер экрана, надо выполнить следующие действия: сначала следует вызвать статический метод getDefaultToolkit(), класса Toolkit, который вернет объект Toolkit. Класс Toolkit содержит много методов, предназначенных для взаимодействия с оконной системой конкретной платформы. Затем надо вызвать метод getScreenSize(), который вернет размер экрана в виде объекта Dimension. Этот объект содеожит ширину и высоту в общедоступных переменных width и height. Мы также предоставим пиктограмму для фрейма. Поскольку процесс изображения рисунков на экране также зависит от ОС, для загрузки рисунка нам снова нужен объект Toolkit. Затем этот рисунок устанавливается в качестве пиктограммы.
>
> Image img = kit.getImage("icon.gif");
> setIconImage(img);     setTitle("CenteredFrame")

> **Отрисовка компонентов**
> - Отрисовка производится в методе paintComponent().
> - Для перерисовки по требованию вызывается метод repaint().  
    > Пример 32.
> ```
> class NotHelloWorldPanel extends JPanel {
> public void paintComponent(Graphics g) {
> super.paintComponent(g);
> g.drawString("Not a Hello, World program",
> MESSAGE_X, MESSAGE_Y);
> }
> public static final int MESSAGE_X = 75;
> public static final int MESSAGE_Y = 100;
> }
> ```
> Комментарий к примеру 32.    
> Можно было расширить класс JComponent.   
> JPanel предназаначен служить контейнером, котрый может содержать в себе другие компоненты, но можно также рисовать непосредственно в нем. Однако следует иметь в виду, что панель непрозрачна, а это значит, что она отвечает за рисование всех пикселей в ее пределах. Простейший способ достичь того же - залить панель цветом фона, вызвав super.paintComponent(), в методе paintComponent каждого подкласса панели.   
> В целях экономии времени на перерисовку логично запоминать однажды нарисованный статичный объект как рисунок в памяти. При использовании Swing для этого не надо предпринимать дополнительных действий по выделению памяти и.д. Используется т.н. механизм «двойной буферизации», реализующий сохранение информации на уровне механизмов отрисовки. Для одного участка «видимой области» приложения используется не более одного изображения-буфера. Методы класса JComponent:
> - setDoubleBuffered(boolean aFlag). Устанавливает, буферизует ли объект свой вывод.
> - boolean isDoubleBuffered(). Возвращает булевское значение, показывающее, используется ли двойная буферизация, или нет
9. JavaFX. Класс Application и жизненный цикл приложения. Stage. Scene.
> **JavaFX**
> JavaFX представляет инструментарий для создания кроссплатформенных графических приложений на платформе Java.   
> С помощью JavaFX можно создавать программы для различных операционных систем: Windows, MacOS, Linux и для самых различных устройств: десктопы, смартфоны, планшеты, встроенные устройства, ТВ. Приложение на JavaFX будет работать везде, где установлена исполняемая среда Java (JRE).   
> JavaFX предоставляет большие возможности по сравнению с рядом других подобных платформ, в частности, по сравнению со Swing. Это и большой набор элементов управления, и возможности по работе с мультимедиа, двухмерной и трехмерной графикой, декларативный способ описания интерфейса с помощью языка разметки FXML, возможность стилизации интерфейса с помощью CSS, интеграция со Swing и многое другое.   
> История JavaFX фактически началась в первой половине 2000-х годов, когда разработчик по имени Крис Оливер (Chris Oliver), будучи работником компании SeeBeyond, разработал для создания графических интерфейсов новый язык F3 (Froms Follows Functions). Впоследствии в 2005 году SeeBeyond была приобретена компанией Sun Microsystems (которая на тот момент развивала язык Java до покупки компанией Oracle). F3 был переименован в JavaFX, а Крис Оливер продолжил работу над новой платформой уже в рамках компании Sun. И в мае 2007 года Sun Microsystems публично анонсировала новую платформу для создания графических приложений. А 4 декабря 2008 года вышел JavaFX 1.0 SDK.   
> После приобретения Sun Microsystems компанией Oracle в 2010 году была анонсирована, а в 2011 году вышла в релиз версия JavaFX 2.0. В первой версии JavaFX фактически представлял скиптовый язык. Во второй версии был полностью изменен подход. Скриптовый язык был убран, а платформа была полностью переписана фактически с нуля. Теперь создавать приложения можно было с помощью любого языка, который поддерживала JVM. Были добавлены новые API, интеграция со Swing и много других вещей.  
> Следующими важными вехами в развитии платформы стали версии JavaFX 8 и особенно JavaFX 9, которая вышла в сентябре 2017 года вместе с Java 9 и привнесла в платформу модульность. И если раньше JavaFX поставлялась вместе с Java SE, то сейчас JavaFX отделена от основной функциональности Java SE и используется как отдельный модуль. Последняя версия фреймворка - JavaFX 12 - вышла в марте 2019 года.  
> На данный момент JavaFX представляет предпочтительный способ для создания графических приложений с помощью языка Java, который пришел на смену AWT и Swing. Также стоит отметить, что для работы с JavaFX вместо Java теоретически можно использовать любой язык программирования, который поддерживается JVM.

> **Класс Application и жизненный цикл приложения**
> ```
> import javafx.stage.Stage;
> import javafx.scene.Scene;
> import javafx.scene.Group;
> import javafx.scene.text.Text;
> public class Main extends Application{
> public static void main(String[] args) {
> Application.launch(args);
> }
> @Override
> public void start(Stage stage) {
> // установка надписи
> Text text = new Text("Hello from JavaFX!");
> text.setLayoutY(80);    // установка положения надписи по оси Y
> text.setLayoutX(100);   // установка положения надписи по оси X
> Group group = new Group(text);
> Scene scene = new Scene(group);
> stage.setScene(scene);
> stage.setTitle("First Application");
> stage.setWidth(300);
> stage.setHeight(250);
> stage.show();
> }
> }
>```
> Вкратце разберем этот класс. Главный класс приложения JavaFX должен наследоваться от класса javafx.application.Application. Этот класс имеет один абстрактный метод, который нам нужно реализовать:  
> public void start(Stage stage) {}

> **Stage**
> В этот метод в качестве параметра передается объекта Stage, который представляет пользовательский интерфейс. Например, на десктопах Stage будет представлять графическое окно. При запуске приложения, когда среда JavaFX будет вызывать данный метод и передавать в него объект Stage.   
> Что нам нужно для создания графического интерфейса? Прежде всего нам нужны различные визуальные элементы, например, кнопки, текстовые поля, списки, изображения и так далее. JavaFX предоставляет большой набор встроенных визуальных элементов. В данном случае мы используем визуальный компонент javafx.scene.text.Text, который представляет простую текстовую надпись. При создании элемента Text мы можем передать ему выводимый текст, а также настроить его положение с помощью его методов:
> ```
> Text text = new Text("Hello from JavaFX!");     // создание надписи 
> text.setLayoutY(80);        // установка положения надписи по оси Y 
> text.setLayoutX(100);   // установка положения надписи по оси X
> ```

> **Scene
> Все визуальные элементы, которые мы хотим отобразить в Stage, помещаются в объект javafx.scene.Scene или на сцену. Scene - это контейнер верхнего уровня для всех графических элементов. Однако напрямую в Scene объект Text мы поместить не можем. Класс Scene предусматривает установку корневого элемента или контейнера, который содержит все остальные элементы.
> Таким образом, вначале элемент Text помещается в элемент Group, который представляет контейнер для группы элементов. Затем элемент Group устанавливается в качестве корневого элемента Scene. И в конце элемент Scene устанавливается для объекта Stage.
> ```
> Group group = new Group(text);  // создание и установка группы элементов 
> Scene scene = new Scene(group);     // создание сцены 
> stage.setScene(scene);                  // установка сцены для объекта Stage 
> ```
> В конце метода start мы можем настроить объект Stage, например, задать заголовок окна, а также его размеры:
> ```
> stage.setTitle("First Application"); // установка заголовка окна 
> stage.setWidth(300);        // установка ширины окна 
> stage.setHeight(250);       // установка длины окна 
> stage.show();               // отображаем окно на экране устройства 
> ```
> С помощью метода show объект Stage отображается на экране устройства.
> Но класс Main, как и всякий главный класс приложения Java, начинает свою работу с метода main. И в методе, чтобы запустить само приложение JavaFX, представленное классом Application, вызывается метод launch():
> ```
> public static void main(String[] args) {
> ```

10. Графические элементы. Класс Node. Взаимодействие с пользователем и обработка событий.
> **Графические элементы**  
> Все графические элементы, которые используются в объекте Scene и добавляются в Scene Graph, должны представлять класс javafx.scene.Node или иначе узел. Все встроенные классы визуальных графических элементов или узлы, например, кнопки, текстовые поля и другие, наследуется от класса Node.   
> При этом одни узлы Node могут содержать несколько других узлов Node. Например, класс Parent наследуется от Node, но при этом сам может содержать другие узлы Node.

> **Класс Node**
> > Вкратце рассмотрим эту иерархию. Основные классы, которые наследуются от класса Node:
> - javafx.scene.shape.Shape: является базовым классом для создания геометрических двухмерных примитивов (например, линия, прямоугольник, эллипс)
> - javafx.scene.shape.Shape3D: является базовым классом для создания трехмерных объектов
> - javafx.scene.canvas.Canvas: представляет полотно для отрисовки различного содержимого
> - javafx.scene.image.ImageView: элемент для отображения изображений
> - javafx.scene.media.MediaView: элемент для работы с мультимедиа
> - javafx.embed.swing.SwingNode: элемент для встраивания содержимого Swing в JavaFX
> - javafx.scene.Parent: базовый класс для всех элементов, которые могут содержать другие элементы

> **Взаимодействие с пользователем и обработка событий**
> Для взаимодействия с пользователем в JavaFX используется событийная модель. В этой модели есть источник события - некоторый элемент управления, который генерирует событие, и есть один или несколько слушаетелей или обработчиков события, которые подписываются на событие. Когда элемент управления генерирует событие, то обработчик обрабатывает это событие.
> Базовым классом для всех событий является класс javafx.event.Event, который унаследован от класса java.util.EventObject. При генерации событии, например, при нажатии на кнопку, создается объект Event, через который передается информация о событии. В данном случае при нажатии на кнопку будет генерироваться событие типа javafx.event.ActionEvent (который наследуется от Event).   
> Для определения обработчика события используется функциональный интерфейс EventHandler.  
> Интерфейс EventHandler типизируется типом, который унаследован от класса Event и который по сути представляет событие. В нашем случае это класс ActionEvent.   
> Для прикрепления обработчика события EventHandler к событию элемента управления применяется метод btn.setOnAction(), в который передается реализация интерфейса EventHandler. В методе handle определяются действия, которые будут вызываться при нажатии на кнопку  
> Нередко вместо определения явной реализации интерфейса EventHandler применяются лямбда-выражения. Например, мы могли бы переписать метод btn.setOnAction() следуюшим образом:

11. Нововведения Java 7.0.
> 1. Структура языка  
     >   1.1. Использование строк в операторе switch   
     > Пример 33.
> ```
> switch (param) {
> case "plain":
> System.err.println("bear");
> break;
> case "mountain":
> System.err.println("tiger");
> break;
> case "swamp":
> System.err.println("cockroach");
> break;
> case "forest": case "island":
> System.err.println("snake");
> break;
> }
> ```
>   1.2. Подчеркивание в числах  
> int one_million = 1_000_000;  
>   1.3. Multi-Catch  
> Пример 34.
> ```
> try {
> ...// we are using reflection here
> } catch (ClassCastException e) {
> doSomethingClever(e);
> throw e;
> } catch(InstantiationException | NoSuchMethodException | InvocationTargetException e) {
> log(e);
> throw e;
> }
>```
>   1.4. оператор <> - diamond (брилиант)   
> List<String> strList = new ArrayList<>();
> 2. Библиотеки   
     > • NIO2   
     > Имеется полный доступ к файловой системе: можно писать в файл через потоки или каналы, перебирать, копировать, перемещать и удалять файлы, создавать ссылки, получать атрибуты, сравнивать пути, «подсматривать» за файловой системой.  
     > • Concurrency  
     > • Удобный фреймворк для распараллеливаемых задач Fork/Join  
     > • Новый класс синхронизации Phaser (барьер, в дополнение к CyclicBarrier и CountDownLatch)  
     > • Новый интерфейс TransferQueue (расширяет BlockingQueue, имплементирован в LinkedTransferQueue)  
     > • Client features  
     > • Nimbus LaF – новый кроссплатформенный look-and-feel   
     > • JLayer – декоратор для swing-компонент   
     > • XRender pipeline – использование ресурсов графических видеокарт для отрисовки Java2D для повышения производительности.   
     > • новый API AWT (полупрозрачные и фигурные окна, смешивание "тяжелых" и "лёгких" компонент (HW/LW))
> 3. Виртуальная Машина  
     > • The DaVinci Machine project   
     > Этот проект прототипирует ряд расширений для JVM, таким образом, что она может запускать приложения, написанные не на Java, с уровнем производительности, сравнимым с самой Java. Акцент делается на доработке существующего байт-кода и архитектуры выполнения с расширениями общего назначения для работы с отличными от Java языками.   
     > • InvokeDynamic bytecode   
     > Исполнение метода требовало точного имени метода, списка параметров и возвращаемого значения на этапе компиляции. Новая инструкция Байткода InvokeDynamic позволяет использовать позднее связывание для методов с помощью MethodHandler. При первом вызове метода находится метод и создаётся handler. Последующие вызовы его переиспользуют.

12. Нововведения Java 8.0.
> Java
> - Ламбда-выражения;
> - Ссылки на методы;
> - Повторяемые аннотации;
> - Аннотации на типы данных;
> - Рефлексия для параметров методов;
> - Методы по-умолчанию.
    > Коллекции
> - Новый API для потоков;
> - Параллельная сортировка массивов;
> - Улучшение производительности HashMaps.
    > Компактные сборки Java
> - Возможность создания профилей для платформы Java SE, которые включают в себя не всю платформу целиком, а некоторую ее часть.
    > Безопасность
> - Новая реализация AccessController.doPrivileged, позволяющая устанавливать подмножество привелегий без необходимости проверки всех остальных уровней доступа;
> - Password-based алгоритмы стали более устойчивыми;
> - Добавлена поддержка SSL/TLS Server Name Indication (NSI) в JSSE Server;
> - Улучшено хранилище ключей (KeyStore);
> - Добавлен алгоритм SHA-224;
    > Инструменты
> - Добавлена команда jjs для использования нового JavaScript-движка Nashorn;
> - Команда java может запускать JavaFX приложения;
> - Добавлена команда jdeps для анализа .class-файлов.
    > Интернационализация
> - Добавлена поддержка Unicode 6.2.0;
> - Добавлен новый API для Calendar и Locale;
> - Новый API Date/Time;
> - Новый движок JavaScript Nashorn;
    > [N]IO
> - Улучшена производительность конструктора java.lang.String(byte[], *) и метода java.lang.String.getBytes().
> - Добавлен стандартный класс для работы с Base64;
> - Добавлена поддержка беззнаковой арифметики;
> - Удален мост JDBC-ODBC;
> - Удален PermGen, изменен способ хранения мета-данных классов.
> - Добавлено несколько новых классов для потокобезопасной работы с ConcurrentHashMap, Atomics, ForkJoinPool, Locks.


## Вопросы к 6 лабе:

1. Распределённая система. Причины создания, принципы построения, последствия распределённости, требования к распределённым системам.

> **Распределенная система** – это собрание независимых компьютеров (узлов), соединенных сетью и программным обеспечением, обеспечивающим их совместное функционирование.
> 
> **Причины создания распределенных приложений**:
> 1. **Необходимость совместного использования общих ресурсов (данных, устройств, приложений). 
> 2. **Улучшение функциональных характеристик системы** (производительности, повышения надежности и устойчивости к сбоям, упрощение и удешевление за счет специализации компонентов, отношения цена/производительность).
> 
> **Принципы построения**:
> 1. **Функциональное разделение.** Узлы выполняют различные задачи (клиент / сервер, хост / терминал, сбор данных / обработка данных). Решение – создание разделяемых сервисов, которые управляют набором ресурсов и предоставляют услуги пользователям. 
> 2. **Естественное разделение.** Разделение определяется задачей (система обслуживания сети супермаркетов, сеть для обеспечения коллективной работы). Функциональная нагрузка одинаковая у однотипных узлов.
> 3. **Балансировка нагрузки.** Функциональность может повторяться. Задачи назначаются на процессоры таким образом, чтобы нагрузка была равномерной. Такой подход обеспечивает наибольшую эффективность использования вычислительных ресурсов.
>
> **Последствия распределённости**:
> 1. **Параллельность.** Параллельное выполнение (вопросы синхронизации, «гонки потоков»), совместное использование ресурсов (коллизии при доступе к данным, сервисам, устройствам), типичные проблемы (взаимные блокировки, ненадежные коммуникации).
> 2. **Нет “глобального” времени** (асинхронная передача сообщений, ограниченная точность синхронизации часов).
> 3. **Нет состояния системы.** В распределенной системе нет ни одного процесса, который бы знал текущее глобальное состояние системы. Это следствие параллелизма и механизма передачи данных.
> 4. **Сбои.** Процессы выполняются автономно, изолированно. Неудачи отдельных процессов могут остаться необнаруженными. Отдельные процессы могут не подозревать об общесистемном сбое. Сбои происходят чаще, чем в централизованной системе. Новые причины сбоев (которых не было в монолитных системах). Сетевые сбои изолируют процессы и фрагментируют систему на изолированные части.
>
> Требования к распределённым системам.
> 1. **Открытость.** Гарантирует расширяемость, возможность повторного использования, использование открытых протоколов и стандартов. Важными факторами являются наличие четких спецификаций и полной документации, опубликованные интерфейсы, тестирование и проверка на многих платформах.
> 2. **Безопасность.** Физическая распределенность означает возможность доступа злоумышленников к компонентам. Необходимо обеспечить посылку важной информации по сети безопасно и эффективно. Это достигается, например, с помощью аутентификации (процедуры проверки подлинности данных) и авторизации (предоставление определённому лицу или группе лиц прав на выполнение определённых действий; а также процесс проверки данных прав при попытке выполнения этих действий), шифрования данных.
> 3. **Масштабируемость.** Распределенная система масштабируема, если она остается эффективной при увеличении числа обслуживаемых пользователей или ресурсов. Возникает проблема стоимости физических ресурсов (растет при увеличении числа пользователей) и потери производительности (увеличиваются с ростом размера данных и количества пользователей). Для «обхода узких мест» используется децентрализация алгоритмов (Пример – Domain Name Service (DNS)), тиражирование и кэширование данных.
> 4. **Обработка сбоев.** Сбои возникают чаще, чем в централизованных системах, но обычно носят локальный характер. Обработка сбоев включает в себя: диагностику (например, ошибки передачи могут быть обнаружены с помощью контрольных сумм. Однако, в ряде случаев, может быть невозможна. Например, невозможно определить, удаленный сервер не работает или просто очень загружен?), маскирование (многие сбои могут быть скрыты, однако, в ряде случаев маскирование может быть невозможно или не всегда приводит к правильным последствиям) и восстановление.
> 5. **Прозрачность.** Это сокрытие гетерогенной (разнородной) и распределенной структуры системы таким образом, чтобы пользователю система представлялась монолитной. Степень прозрачности взаимосвязана с производительностью. Различают:
> - **Прозрачность доступа.**
> Скрывается разница в представлении данных и доступе к ресурсам.
> - **Прозрачность расположения.**
> Скрывается местоположения ресурса.
> - **Прозрачность переноса.**
> Скрывается факт перемещения ресурса в другое место.
> - **Прозрачность смены местоположения.**
> Скрывается факт перемещения ресурса в другое место в процессе обработки.
> - **Прозрачность репликации.**
> Скрывается факт и особенности репликации (механизм синхронизации содержимого нескольких копий объекта (например, содержимого базы данных)) ресурса.
> - **Прозрачность параллелизма.**
> Возможность нескольким процессам параллельно работать с ресурсами, не оказывая влияния друг на друга.
> - **Прозрачность обработки ошибок.**
> Защита программных компонентов от сбоев, произошедших в других программных компонентах; восстановление после сбоев.
>
> **Критически важными являются:**
> - Прозрачность доступа. 
> - Прозрачность расположения. 
> - Прозрачность паралеллизма.
> 6. **Управляемость**. Распределенные ресурсы не имеют центральной точки управления. Локальная оптимизация не всегда означает глобальную оптимизацию (нужно учитывать гетерогенность и другие особенности, нужен глобальный взгляд на проблему, он не всегда возможен (есть системы, никому конкретно не принадлежащие)).

2. Распределённая система. Сложности при реализации, модели распределённых систем, архитектура и основные принципы, преодоление сложности.
> **Сложности при реализации** 
> 1. **Выбор архитектуры.** Важнейшие характеристики системы очень сильно зависят от выбранной архитектуры. Практически невозможно отказаться от принятых в начале проектирования неверных решений.
> **Решение:** использование широко известных шаблонов (образцов) архитектур. 
> 2. **Гетерогенность среды** (разнородность). Различаются:
> - Сетевые инфраструктуры. 
> - Оборудование (например, Intel и Motorolla). 
> - Программное обеспечение (например, UNIX sockets и Winsock calls).
> - Языки программирования. 
> - Представления данных. 
> - Различные компоненты системы выполняются на различных платформах. Различия должны быть скрыты. Интерфейсы и реализация могут быть разными, но базовые концепции обычно неизменны. Средства борьбы с гетерогенностью – стандарты. 
> **Решения:**
> - Использование распространенных открытых стандартов и протоколов. 
> - Использование промежуточного программного обеспечения (middleware).   
> 
> Middleware: промежуточный программный слой:
> - Позволяет гетерогенным узлам взаимодействовать. 
> - Определяет однородную вычислительную модель.
> - Поддерживает один или несколько языков программирования.
> - Обеспечивает поддержку распределенных приложений (вызов удаленных объектов, удаленный вызов SQL, распределенную обработку транзакций).
> Примеры: CORBA, JavaEE, Microsoft DCOM.
> 3. **Сложность развертывания.**
> - Фрагментация (разделение приложения на модули развертывания).
> - Конфигурация (связь модулей друг с другом (зависимости)).
> - Размещение (выгрузка модулей в целевую систему, распределение вычислительных модулей между узлами (статическое или динамическое), использование специализированных инструментальных средств).
> 4. **Сложность отладки.** Нет глобального состояния. Параллельность приводит к неповторяемости (невоспроизводимости) результатов выполнения. Компоненты распределены по разным узлам.

> **Модели распределённых систем** 
> 1. **Модели архитектуры.** Модель архитектуры распределенной системы должна содержать решение двух проблем: физическое размещение компонентов между узлами и взаимодействие между компонентами. Реальные функции отдельных компонентов не указываются, указываются:
> - Расположение (размещение по узлам). 
> - Шаблоны распределения данных и задач по их обработке. 
> - Взаимодействие компонентов (роли компонентов, шаблоны взаимодействия).
> 2. **Другие модели.** Формальное описание различных параметров и свойств системы, модели взаимодействия, обработки ошибок, безопасности, и т.д.

> **Архитектура**
> - Определяет разделение системы на наиболее крупные составные части.
> - Определяет конструктивные решения, которые после их принятия с трудом поддаются изменению.
> - Отображает общий взгляд разработчиков на результаты проектирования системы: идентификация главных компонентов системы, способов их взаимодействия, выбор основополагающих решений, не подлежащих изменению в будущем.
> **Основные принципы архитектуры**
> - **Согласованность.** Частичное знание системы позволяет предсказать остальное.
> - **Ортогональность.** Функции независимы и специфицированы по отдельности.
> - **Соответствие.** Включаются только функции, соответствующие существенным требованиям к системе, нет ненужных функций.
> - **Экономичность.** Отсутствие дублирования.
> - **Прозрачность.** Функции должны быть известны пользователю.
> - **Общность.** Если функция должна быть введена, ее следует вводить в таком виде, чтобы она отвечала как можно большему числу назначений.
> - **Открытость.** Можно использовать функцию иначе, чем это предполагалось при проектировании.
> - **Полнота.** Введенные функции должны с учетом экономических и технологических ограничений как можно полнее соответствовать требованиям и пожеланиям пользователя.

> **Преодоление сложности**
> 1. **Использование типовых решений - образцов проектирования.** Каждое типовое решение описывает некую повторяющуюся проблему и ключ к ее разгадке, причем таким образом, что вы можете пользоваться этим ключом многократно, ни разу не придя к одному и тому же результату.
> 
> **Структура типовых решений**
> - Название решения.
> - Назначение (аннотация).
> - Мотивация, применимость.
> - Принцип действия (структура, участники, отношения).
> - Результаты.
> - Реализация.
> 
> 2. **Разделение системы на слои (расслоение).** Основная идея: независимость нижележащих уровней от вышележащих. Основная задача: уменьшать сложность систем, разделяя их на слои и сервисы:
> - Слой (уровень): группа сильно связанных и закрытых элементов, реализующих одну функциональность.
> - Сервис: функциональность, обеспечиваемая для вышестоящего слоя.
>
> **Три основных слоя**
> 
> Слои:
> 
> - представление (presentation).
> - домен (domen) – предметная область, бизнес-логика.
> - работа с данными (data source). 
> 
> Рекомендуется различать:
> - Слой (layer) – логическое разделение.
> - Уровень или Ярус (tier) – физическое разделение.
> 
> **Итоги**
> - Распределенная система – это автономные (но соединенные средой передачи данных) узлы. Взаимодействие осуществляется посредством передачи сообщений.
> - Много доводов в пользу того, что распределенные системы нужны и их нужно уметь строить.
> - Распределенные системы существуют и их нужно уметь развивать и поддерживать.
> - При разработке распределенных систем возникают специфические проблемы.
> - Используется модель слоев для снижения сложности системы. Middleware обеспечивает дополнительное удобство и дополнительные сервисы.
> - Выбор модели архитектуры зависит от особенностей задачи.
>   - Клиент – сервер.
>   - Модель предоставления услуг пулом серверов.
>   - Модель прокси-  и кэш-серверов.
>   - Модель равных процессов.




3. JDBC. Типы драйверов. Основные цели интерфейса JDBC. Примеры использования JDBC. Основы программирования JDBC. Предварительно подготовленные команды. Метаданные.
> **JDBC.** 
>
> В 1996 году компания Sun выпустила первую версию интерфейса для организации доступа Java – приложений к базам данных (БД) JDBC (Java DataBase Connectivity). Настоящий интерфейс позволяет программистам соединяться с БД, запрашивать и обновлять данные с помощью языка SQL (Structured Query Language), который фактически стал стандартным средством взаимодействия с реляционными базами данных.
>
> Java и JDBC имеют весомое преимущество по сравнению с другими инструментами для работы с БД. Программы, созданные с помощью Java и JDBC, не зависят от используемой платформы и поставщика программного обеспечения. 
> 
> Средства JDBC неоднократно обновлялись. В состав JDK 1.2, выпущенной в 1998 году, была включена версия 2 JDBC. В JDK 1.4 и 1.5 была включена версия 3 JDBC и т.д.
>
> С самого начала поставщики программного обеспечения для БД поддерживали идею создания компанией Sun стандартного сетевого протокола доступа к БД, но при условии, что за основу будет принят их собственный протокол. В конечном итоге поставщики СУБД и инструментов доступа к базам всё-таки согласились с тем, что сотрудники Sun создали Java API для SQL-доступа к данным и диспетчер драйверов, который позволил бы подключать к базам драйверы независимых производителей. Такой подход позволял производителям СУБД создавать собственный драйверы, которые подключались бы с помощью диспетчера и должны лишь соответствовать требованиям API диспетчера драйверов.
> 
> В результате было создано два интерфейса. Разработчики приложений используют JDBC API, а поставщики БД и инструментальных средств – JDBC Driver API. Подход, используемый при создании JDBC, основан на модели ODBC(Open Database Connectivity) — интерфейса доступа к БД, разработанного фирмой Microsoft: программы, соответствующие API, могут взаимодействовать с диспетчером драйверов JDBC, который, в свою очередь, использует присоединенные драйверы для организации взаимодействия с БД.

> **Типы драйверов.** 
> 
> 1. **Драйвер типа 1.** Транслирует JDBC в ODBC и для взаимодействия с БД использует драйвер ODBC. Sun включила в состав JDK один такой драйвер – мост JDBC/ODBC. Но для его использования требуется соответствующим образом установить и конфигурировать ODBC драйвер. В первом выпуске JDBC этот мост предполагалось использовать только для тестирования, а не для рабочего применения. В настоящее время имеется большое количество более удачных драйверов. 
> 2. **Драйвер типа 2.** Создается преимущественно на Java и частично на собственном языке программирования, который используется для взаимодействия с клиентским API БД. Для использования такого драйвера нужно помимо библиотеки Java установить специфический для данной платформы код.
> 3. **Драйвер типа 3.** Создается только на основе библиотеки Java, в которой используется независимый от БД протокол взаимодействия сервера и базы. Этот протокол позволяет транслировать запросы в соответствии со спецификой конкретной базы. Если код, зависящий от БД, находится только на сервере, доставка программ существенно упрощается. 
> 4. **Драйвер типа 4.** Представляет собой библиотеку Java, которая транслирует JDBC-запросы непосредственно в протокол конкретной БД.
>
> Большинство поставщиков БД применяют драйверы типа 3 или 4. Кроме того, некоторые компании специализируются на создании драйверов, которые позволяют добиться более полного соответствия принятым стандартам, поддерживают большее количество платформ, обладают более высокой производительностью или надежностью, чем драйверы, предлагаемые производителями СУБД.

> **Основные цели интерфейса JDBC.** 
> 
> 1) Разработчики создают программы на языке Java, пользуясь для доступа к БД стандартными средствами языка SQL, при этом они следуют только соглашениям языка Java.
> 2) Производители СУБД и инструментальных средств поставляют драйверы только низкого уровня.

> **Примеры использования JDBC.**
> 
> Согласно традиционной модели клиент/сервер, графический пользовательский интерфейс реализуется на стороне клиента, а БД располагается на стороне сервера. В этом случае драйвер JDBC находится на стороне клиента.
> 
> Однако современная тенденция развития программного обеспечения заключается в переходе от архитектуры клиент/сервер к «трехуровневой модели»
> 
> В ней клиент не формирует обращений к БД. Вместо этого он обращается к средствам промежуточного уровня на сервере, который, в свою очередь, выполняет запросы к БД. Трехуровневая модель отделяет визуальное представление (на компьютере-клиенте) от бизнес-логики (промежуточный уровень) и данных (в базе данных). Таким образом, становится возможным доступ к тем же данным и тем же бизнес-правилам посредством клиентов различных типов, например, Java-приложений, апплетов и Web-форм.
> 
> Взаимодействие между клиентом и промежуточным уровнем может быть реализовано на основе протокола HTTP (при использовании Web-браузера в качестве клиента), средств RMI (при использовании приложений или апплетов) или с помощью какого-либо другого механизма. JDBC используется для управления взаимодействием между промежуточным уровнем и БД.


> **Основы программирования JDBC.** 
> 
> Классы, используемые для программирования JDBC, содержатся в пакетах java.sql и javax.sql. 
> 
> Класс _DriverManager_ отвечает за выбор драйверов БД и создание нового соединения с БД. Однако перед тем, как диспетчер активизирует драйвер, его надо зарегистрировать. Имя драйвера можно задать в командной строке:
> 
> _java –Djdbc.drivers=org.postgresql.Driver MyClass_
> 
> Кроме того, приложение может установить системное свойство с помощью вызова:
> 
> _System.setProperty("jdbc.drivers", "org.postgresql.Driver");_
> 
> Драйвер также можно зарегистрировать вручную, загрузив его класс:
> 
> _Class.forName("org.postgresql.Driver");_
> 
> Такой подход применяют, если диспетчер не может загрузить драйвер из-за ограничений конкретного драйвера либо в том случае, когда программа выполняется в среде контейнера, например, сервлета.
> 
> После регистрации драйвера можно установить соединение с БД. При работе с JDBC база данных представляется с помощью URL (Uniform Resource Locator). Для PostgreSQL он принимает одну из следующих форм:
> - _jdbc:postgresql:database_
> - _jdbc:postgresql://host/database_
> - _jdbc:postgresql://host:port/database_
> 
> Для подключения к базе нужно использовать класс Connection:
> 
> _Connection connection = DriverManager.getConnection(url, username, password);_
> 
> Например:
> 
> _Connection connection = DriverManager.getConnection("jdbc:postgresql://localhost:5432/MyTest", "postgres", "root");_
> 
> Для указания драйвера, URL, имени пользователя и пароля удобно применять файл свойств:
> 
> Метод _getConnection()_ возвращает объект _Connection_, с помощью которого создаётся объект _Statement_, который используется для выполнения SQL – команд. Метод _executeQuery()_ возвращает объект _ResultSet_, который можно использовать для построчного просмотра результатов.
>
> В классе ResultSet итератор располагается в начале работы перед первой строкой, поэтому для перемещения его к первой строке нужно вызвать метод next(). Строки в наборе результатов располагаются совершенно произвольно. Если порядок следования важен, его необходимо установить с помощью оператора ORDER BY. 
> 
> При обработке каждой отдельной строки нужно с помощью специальных методов получить содержимое каждого столбца. 
> 
> resultSet.getString(1);
> 
> resultSet.getDouble("Price"); 
> 
> Для каждого типа данных языка Java предусмотрен отдельный метод извлечения информации, например, getString() и getDouble(). Для каждого из них реализовано два варианта, один из которых предполагает числовой, а второй – строковый параметр. При использовании числового параметра метод извлечет данные из столбца с указанным номером, нумерация столбцов начинается с 1. При использовании строкового параметра метод извлечет данные из столбца с указанным именем. 
> 
> Если указанный тип не соответствует фактическому типу, метод извлечения данных выполняет преобразование. Например, метод resultSet.getString("Price") преобразует число с плавающей точкой из столбца Price в строку. 
> 
> Типы данных SQL и Java не всегда совпадают. В таблице 3 приведен список основных типов данных языка SQL и их эквивалентов в Java.
> 
> Метод executeUpdate() возвращает количество строк, полученных в результате выполнения SQL-команды. Он может применяться для выполнения команд INSERT, UPDATE и DELETE, а также команд определения данных, в частности, CREATE TABLE и DROP TABLE.
> 
> Закончив работу с классом ResultSet, Statement или Connection нужно вызвать метод close(), так как перечисленные объекты используют структуры данных большого объема и не стоит ждать, пока процедура сборки мусора освободит ресурсы. Метод close() класса Statement автоматически закрывает связанные с ним наборы результатов( если они открыты). Аналогично, метод close() класса Connection закрывает все объекты Statement для этого соединения. Если время существования соединения невелико, нужно поместить вызов метода close() в блок finally, гарантируя, что объект соединения не останется открытым.

> **Предварительно подготовленные команды.**
>
> Вместо создания отдельной SQL-команды для каждого запроса следует предварительно подготовить запрос с подстановочной переменной и многократно использовать его, меняя только значение переменной. Эта возможность существенно повышает эффективность работы программы. Перед каждым выполнением запроса СУБД создает план его эффективного исполнения. Предварительно подготавливая запрос для последующего многократного повторного использования, можно избежать повторного создания плана. Подстановочная переменная в запросе обозначается символом ?. При использовании нескольких подстановочных переменных нужно следить за их расположением, чтобы правильно выполнять подстановку фактических значений. 
> 
> String s = "SELECT name, price FROM tovar WHERE price >? AND price <?"; 
> 
> PreparedStatement ps = connection.prepareStatement(s);
> 
> ps.setDouble(1,2000);
> 
> ps.setDouble(2,6000);
> 
> ResultSet rs1 = ps.executeQuery();
> 
> Перед выполнением предварительно подготовленного запроса нужно с помощью метода set() связать подстановочные переменные с их фактическими значениями. Как и при использовании методов get(), класса ResultSet, для различных типов предусмотрены разные методы set(). Например:
> 
> ps.setDouble(1,2000);
> 
> Первый параметр обозначает номер позиции подстановочной переменной, второй – её фактическое значение. При повторном использовании предварительно подготовленного запроса с несколькими подстановочными переменными все связи остаются в силе, если только они не изменены с помощью метода set(). Это значит, что методы set() нужно вызывать только для тех подстановочных переменных, которые изменяются в последующих запросах. Для изменения данных используется метод executeUpdate().

> **Метаданные.**
> 
> В JDBC предусмотрены дополнительные возможности для получения информации о структуре таблиц и самой БД. Например, можно получить список всех таблиц БД либо имена всех столбцов с типами данных в них. Эти сведения пригодятся, если вы пишете программный продукт для работы с произвольной БД.
> 
> В языке SQL  информация о структуре БД и её компонентов называется метаданными. Информация о структуре БД хранится в классе DatabaseMetaData. Ниже приведен пример получения набора результатов, содержащего информацию обо всех таблицах БД.
>
> DatabaseMetaData meta = connection.getMetaData();
>
> ResultSet mrs = meta.getTables(null, null, null, new String[] {"TABLE"});
>
> Метод getTables(String catalog, String schemaPattern, String tableNamePattern String types[]) представляет описание всех таблиц в каталоге, которые соответствуют шаблонам схемы и имен таблиц, а также заданным типам. Схемой называется группа связанных таблиц и полномочий доступа. Каталогом называется связанная группа схем. Параметры catalog и schemaPattern могут быть пустыми строками(" ") для извлечения таблиц без каталога и схемы либо иметь значение null, если нужно возвращать таблицы без учета каталога или схемы. Массив types содержит имена типов таблиц: TABLE, VIEW, ALIAS и т.д. Если для types задано значение null, то будут возвращены таблицы всех типов. Результат выполнения запроса содержит 5 столбцов, которые имеют тип String и показаны в таблице 4.
>
> Если нас интересует имя таблицы, т.е. третий столбец, то нужно вызвать метод mrs.getString(3).
>
> Сведения о структуре набора результатов хранятся в классе ResultSetMetaData.
>
> ResultSet rs = statement.executeQuery("SELECT * FROM  item");
>
> ResultSetMetaData rsmd= rs.getMetaData();
>
> После получения результатов выполнения запроса можно определить количество столбцов методом getColumnCount(), имена столбцов getColumnLabel(int column) и т.д.