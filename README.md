# Вопросы

## Вопросы к 5 лабе:

1. Класс Graphics. Работа с цветом. Работа со шрифтами.

> java.awt.Graphics - базовый класс, предназначенный для рисования в контекстах компонентов, в изображениях в памяти и
> т.д.
> - void drawArc(int x, int y, int width, int height, int startAngle, int arcAngle) - Этот метод вычерчивает (fillArc
    заполняет) дугу, ограниченную прямоугольником (x,y,width, height), начинающуюся с угла startAngle и имеющую угловой
    размер arcAngle. Ноль градусов соответствует положению часовой стрелки на 3 часа, угол отсчитывается против часовой
    стрелки (например, 90 градусов соответствуют 12 часам, 180 - 9 часам, и так далее).
> - void drawString(String str, int x, int y) - Этот метод выводит строку с использованием текущих шрифта и цвета. Точка
    с координатами (х,у) соответствует левой границе базовой линии символов, а не левому верхнему углу, как это принято
    в других методах рисования. Базовая линия (baseline) - линия, по которой выравниваются нижние границы символов.
> - и т.д.

> **Работа с цветом**
>
> Класс java.awt.Color.
> - Можно использовать константы класса (Color.BLUE, Color.RED) для задания какого-либо из общеупотребительных цветов (
    blue,red).
> - Для создания нового цвета можно использовать один из описанных ниже конструкторов:
> - Color(int, int, int) - параметрами для этого конструктора являются три целых числа в диапазоне от 0 до 255 для
    красного, зеленого и голубого компонентов цвета.
> - Color(int) - у этого конструктора - один целочисленный аргумент, в котором в упакованном виде заданы красный,
    зеленый и голубой компоненты цвета. Красный занимает биты 16-23, зеленый - 8-15, голубой - 0-7.
> - Color(float, float, float) - последний из конструкторов цвета, принимает в качестве параметров три значения типа
    float (в диапазоне от 0.0 до 1.0) для красного, зеленого и голубого базовых цветов.
> - Методы получения параметров цвета getRed(), getGreen(), getBlue() - каждый из этих методов возвращает в младших
    восьми битах результата значение соответствующего базового компонента цвета.

> **Работа со шрифтами**
>
> Класс java.awt.Font
> - Константы
> - Конструкторы
>
> Font(String name, int style, int size) - создает новый шрифт с указанным именем, стилем и размером. Имена шрифтов:
> Dialog, Helvetica, TimesRoman, Courier и Symbol. Для указания стиля шрифта внутри данного семейства предусмотрены три
> статические переменные. - Font.PLAIN, Font.BOLD и Font.ITALIC, что соответствует обычному стилю, курсиву и
> полужирному.
> - Методы модификации и получения параметров шрифта (getSize - метод возвращает целое число, представляющее собой
    размер шрифта, isBold, isItalic, isPlain - методы возвращают true в том случае, если стиль шрифта - полужирный (
    bold), курсив (italic) или обычный (plain), соответственно).
>
> Класс java.awt.FontMetrics
> - Содержит методы определения геометрических характеристик шрифтов (getAscent, getDescent, getHeight - эти методы
    возвращают подъем, снижение и ширину шрифта. Сумма подъема и снижения дают полную высоту шрифта. Высота шрифта - это
    не просто расстояние от самой нижней точки букв g и у до самой верхней точки заглавной буквы Т и символов вроде
    скобок. Высота включает подчеркивания и т.п.).

2. Особенности AWT. Менеджеры компоновки.

> - Компоненты являются компонентами ОС
>   - большое количество native-кода
>   - отображение изменяется при смене ОС
> - Применение:
>   - в апплетах
>   - в оконных приложениях
> - Абстрактный класс Component определяет базовую функциональность всех компонентов. Это класс, который инкапсулирует
    все атрибуты визуального интерфейса - обработка ввода с клавиатуры, управление фокусом, взаимодействие с мышью,
    уведомление о входе/выходе из окна, изменения размеров и положения окон, прорисовка своего собственного графического
    представления, сохранение текущего текстового шрифта, цветов фона и переднего плана (более 100 методов).

3. Модель делегирования обработки событий. Событие. Источник. Слушатель. Пример.

> **Модель делегирования обработки событий**
> - Источник генерирует событие и посылает его одному или нескольким слушателям.
> - Слушатель просто ждет поступления события.
> - Получив событие, слушатель обрабатывает его и затем возвращает управление.
> - Слушатели должны зарегистрироваться у источника – события посылаются только зарегистрировавшимся слушателям.
> - Логика кода, обрабатывающего события, отделена от логики интерфейса, генерирующего события.

> **Событие**
>
> Событие – это объект, описывающий изменение состояния источника. В модели обработки событий Java разным типам событий
> соответствуют различные классы Java. Каждое событие является подклассом класса java.util.EventObject. События пакета
> AWT
> являются подклассом java.awt.AWTEvent. Для удобства события различных типов пакета AWT (например, MouseEvent или
> АсtionEvent) помещены в новый пакет java.awt.event. Для каждого события существует порождающий его объект, который
> можно
> получить с помощью метода public Object getSource(), и каждому событию пакета AWT соответствует определенный
> идентификатор, который позволяет получить метод public int getID(). Это значение используется для того, чтобы отличать
> события различных типов, которые могут описываться одним и тем же классом событий. Например, для класса FocusEvent
> возможны два типа событий: FocusEvent.FOCUS_GAINED и FocusEvent.FOCUS_LOST

> **Источник**
> - Источник – объект, генерирующий события. Источник может генерировать несколько типов событий.
> - Регистрация слушателя:   
    public void addTypeListener(TypeListener el) throws java.util.TooManyListenersException   
    public void removeTypeListener(TypeListener el)

> **Слушатель**
> - Слушатель – объект, получающий уведомление о событии.
> - Может быть зарегистрирован одним или несколькими источниками.
> - Должен реализовывать методы для приема и обработки уведомлений.
> - Существует набор интерфейсов **TypeListener**, описывающих методы обработки событий. Например, объекты слушателей
    событий ActionEvent должны реализовывать интерфейс ActionListener. В пакете java.awt.event содержатся интерфейсы
    слушателей для каждого из определенных в нем типов событий (например, для событий MouseEvent здесь определено два
    интерфейса слушателей: MouseListener и MouseMotionListener). Все интерфейсы слушателей событий являются расширениями
    интерфейса java.util.EventListener. В этом интерфейсе не определяется ни один из методов, но он играет роль
    интерфейса-метки, в котором однозначно определены все слушатели событий как таковые.

4. Классы-адаптеры.

> Для каждого интерфейса слушателей событий, содержащего несколько методов, в пакете java.awt.event определен простой
> класс-адаптер, который обеспечивает пустое тело для каждого из методов соответствующего интерфейса. Когда нужен только
> один или два таких метода, иногда проще получить подкласс класса-адаптера, чем реализовать интерфейс самостоятельно. При
> получении подкласса адаптера требуется лишь переопределить те методы, которые нужны, а при прямой реализации интерфейса
> необходимо определить все методы, в том числе и ненужные в данной программе. Заранее определенные классы-адаптеры
> называются так же, как и интерфейсы, которые они реализуют, но в этих названиях Listener заменяется на Adapter:
> MouseAdapter, WindowAdapter и т.д.

5. Статические вложенные классы. Вложенные интерфейсы.

> **Статический вложенный класс** - это простейшая форма вложенного класса, в его объявлении присутствует служебное
> слово static. Если класс вложен в интерфейс, он получает статус статического по умолчанию, и модификатор static, в
> соответствии с принятым соглашением, опускается. Статический вложенный класс может наследовать другие классы,
> реализовывать любые интерфейсы и сам по себе служить объектом расширения для любого класса, обладающего необходимыми
> правами доступа. В объявлении статического вложенного класса, как и обычного класса, разрешается применять модификаторы
> final и abstract. Статические классы, вложенные в другой класс, являются членами последнего и допускают применение любых
> модификаторов доступа.  
> Пример 26.
> ```
> abstract public class ClassA {
> protected static class ClassB {
> ...
>   }
> }
> ```
> **Вложенные интерфейсы** всегда статичны, хотя соответствующий модификатор, static, в соответствии с принятым
> соглашением, принято опускать. Доступ определяется доступом внешнего класса или интерфейса.   
> Пример 27.
> ```
> public class ClassA {
> protected interface InterfaceB {
>       ...
>   }
> }
> ```

6. Нестатические вложенные классы. Локальные классы. Анонимные классы.

> **Нестатические вложенные классы** называются внутренними классами. Объект внутреннего класса всегда ассоциируется с
> т.н. внешним объектом (с соответствующим объектом внешнего класса). Элементы внутреннего класса имеют доступ к полям и
> методам внешнего объекта. Внутренние классы не способны содержать статические члены, кроме полей вида final static,
> инициализируемых константами или постоянными выражениями. Внутренние классы, как и обычные, способны расширять любые
> другие классы, реализовывать интерфейсы и выступать в роли объектов наследования. Вполне допустимо использовать в
> объявлении внутреннего класса модификаторы final и abstract.  
> Пример 28.
> ```
> abstract public class ClassA {
> private class ClassB {
>       ...
>   }
> }
> ```
> **Локальные классы**  
> Разрешается объявлять вложенные классы внутри блоков кода, таких как тело метода, конструктор или блок инициализации.
> Подобный **локальный** внутренний **класс** не является членом класса, к которому относится блок, а принадлежит самому
> блоку – точно так же, как обычная локальная переменная. Такие классы недоступны за пределами внешнего класса, т.к. не
> сущестует способов обращения к ним, но их экземпляры – это обычные объекты, которые позволяется передавать в качестве
> аргументов или возвращать из методов. Единственный модификатор, который допускается применять в объявлении локального
> класса, - это final (модификаторы доступа запрещены). Экземпляры имеют доступ не только к полям и методам внешнего
> объекта, но и к локальным переменным. Однако такие переменные должны быть объявлены как final.   
> Пример 29.
> ```
> public class ClassA {
> public Iterator iterator() {
> class Iter implements Iterator {
> ...
> }
> ...
> return new Iter();
> }
> ```
> **Анонимные классы**
> Анонимные классы описываются непосредственно в выражении new и служат его частью. Тип, указанный после new, является базовым для объявляемого анонимного класса. Могут расширять один класс или реализовывать один интерфейс. Явно писать implements или extends нельзя. Не могут иметь конструкторов, так как имя конструктора должно совпадать с именем класса, а в данном случае класс не имеет имени. Параметры, необходимые для создания объекта, передаются конструктору суперкласса.
> Пример 30.
> ```
> import java.awt.*;
> import java.applet.*;
>
> public class MyApplet extends Applet {
> ...
> public void init() {
> Button btn = new Button(“?”);
> add(btn);
> btn.addActionListener(new ActionListener() {
> public void actionPerformed(ActionEvent e) {
> ((Button)e.getSource()).setLabel(“!”);
>           }
>       });
>   }
> }
> ```
7. Проблемы AWT. Особенности Swing. Look And Feel.
> **Проблемы AWT**:
> - Сходные элементы в различных ОС могут иметь некоторые различия (например, меню, панели прокрутки). 
> - ОС часто имеют элементы GUI, отсутствующие в других ОС (некоторые графические среды программирования, например, X11/Motif, не имеют такого богатого набора компонентов пользовательского интерфейса, как ОС Windows или Macintosh). 
> - Использование native-методов в AWT приводит к возникновению ошибок на конкретных платформах (на разных платформах возникали разные ошибки, приходилось тестировать каждое приложение на каждой платформе).

> **Особенности Swing** 
> - Элементы GUI (меню, кнопки) отрисовываются в пустых окнах. 
> - «Нативные» функции используются только для вывода окна, отрисовки и получения информации о действиях пользователя. 
> - Обладает свойством «легковесности» (lightweight). 
> - Набор элементов GUI более широк, чем в AWT, и может быть еще расширен. 
> - Сильная привязка к «нативным» методам отсутствует, что снижает вероятность возникновения ошибок. 
> - Отображение на различных платформах единообразно.

> **Look And Feel**   
> Программисты, использующие Swing, могут придать своей программе внешний вид в заданном стиле. Программе можно придать различный вид, изменив «стиль» отрисовки компонентов. Есть разработанные «стили» для базовых платформ. Существует возможность создания собственных «стилей». Sun разработала независимый от платформы стиль, названный Metal, который прозвали стилем Java. На рисунках 12-14 показано, как выглядит одна и та же программа при использовании различных стилей.
> Внешний вид программы может изменяться во время исполнения. Перерисовка должна вызываться принудительно.

8. Создание оконных приложений. Отрисовка компонентов.
> **Создание оконных приложений**
> - Используется класс JFrame. 
> - Содержимое окна находится на панели, ссылку на которую можно получить вызовом метода getContentPane(). 
> - Параметрами окна можно управлять.
> Пример 31. 
> ```
> import java.awt.*;
> import javax.swing.*;
> 
> public class CenteredFrameTest {
> public static void main(String[] args) {
> CenteredFrame frame = new CenteredFrame();
> frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
> frame.setVisible(true);
> }
> }
> class CenteredFrame extends JFrame {
> public CenteredFrame() {
> Toolkit kit = Toolkit.getDefaultToolkit();
> Dimension screenSize = kit.getScreenSize();
> int screenHeight = screenSize.height;
> int screenWidth = screenSize.width;
> setSize(screenWidth / 2, screenHeight / 2);
> setLocation(screenWidth / 4, screenHeight / 4);
> Image img = kit.getImage("icon.gif");
> setIconImage(img);     setTitle("CenteredFrame");
> }
> }
> ```
> Комментарий к примеру 31.
> Определяем, что должно произойти, если пользователь закроет фрейм. В данном случае программа должна завершить свою работу. Для этого используется строка кода   
>
> frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); 
> 
> Если бы в программе использовалось несколько фреймов, завершать работу только по тому, что пользователь закрыл один из них, было бы необязательно. По умолчанию закрытый фрейм исчезает с экрана, а программа продолжает работу. 
> Простое создание фрейма не приводит к его автоматическому появлению на экране. В начале своего существования все  фреймы невидимы. Это дает возможность добавлять к фрейму компоненты еще до того, как он впервые появится на экране. Чтобы показать фрейм на экране, вызывается метод setVisible(). 
> Если размер не задан явно, все фреймы по умолчанию имеют размер 0х0 пикселей. В профессиональных приложениях нужно сначала проверить разрешающую способность экрана и написать код, изменяющий размер фрейма в соответствии с полученной величиной: окно, которое прекрасно смотрится на экране портативного компьютера, на экране дисплея с большой разрешающей способностью будет выглядеть как почтовая марка. Для того, чтобы определить размер экрана, надо выполнить следующие действия: сначала следует вызвать статический метод getDefaultToolkit(), класса Toolkit, который вернет объект Toolkit. Класс Toolkit содержит много методов, предназначенных для взаимодействия с оконной системой конкретной платформы. Затем надо вызвать метод getScreenSize(), который вернет размер экрана в виде объекта Dimension. Этот объект содеожит ширину и высоту в общедоступных переменных width и height. Мы также предоставим пиктограмму для фрейма. Поскольку процесс изображения рисунков на экране также зависит от ОС, для загрузки рисунка нам снова нужен объект Toolkit. Затем этот рисунок устанавливается в качестве пиктограммы. 
> 
> Image img = kit.getImage("icon.gif"); 
> setIconImage(img);     setTitle("CenteredFrame")

> **Отрисовка компонентов**
> - Отрисовка производится в методе paintComponent(). 
> - Для перерисовки по требованию вызывается метод repaint().  
> Пример 32.  
> ```
> class NotHelloWorldPanel extends JPanel {
> public void paintComponent(Graphics g) {
> super.paintComponent(g);
> g.drawString("Not a Hello, World program",
> MESSAGE_X, MESSAGE_Y);
> }
> public static final int MESSAGE_X = 75;
> public static final int MESSAGE_Y = 100;
> }
> ```
> Комментарий к примеру 32.    
> Можно было расширить класс JComponent.   
> JPanel предназаначен служить контейнером, котрый может содержать в себе другие компоненты, но можно также рисовать непосредственно в нем. Однако следует иметь в виду, что панель непрозрачна, а это значит, что она отвечает за рисование всех пикселей в ее пределах. Простейший способ достичь того же - залить панель цветом фона, вызвав super.paintComponent(), в методе paintComponent каждого подкласса панели.   
> В целях экономии времени на перерисовку логично запоминать однажды нарисованный статичный объект как рисунок в памяти. При использовании Swing для этого не надо предпринимать дополнительных действий по выделению памяти и.д. Используется т.н. механизм «двойной буферизации», реализующий сохранение информации на уровне механизмов отрисовки. Для одного участка «видимой области» приложения используется не более одного изображения-буфера. Методы класса JComponent:
> - setDoubleBuffered(boolean aFlag). Устанавливает, буферизует ли объект свой вывод. 
> - boolean isDoubleBuffered(). Возвращает булевское значение, показывающее, используется ли двойная буферизация, или нет
9. JavaFX. Класс Application и жизненный цикл приложения. Stage. Scene.
> **JavaFX**
> JavaFX представляет инструментарий для создания кроссплатформенных графических приложений на платформе Java.   
> С помощью JavaFX можно создавать программы для различных операционных систем: Windows, MacOS, Linux и для самых различных устройств: десктопы, смартфоны, планшеты, встроенные устройства, ТВ. Приложение на JavaFX будет работать везде, где установлена исполняемая среда Java (JRE).   
> JavaFX предоставляет большие возможности по сравнению с рядом других подобных платформ, в частности, по сравнению со Swing. Это и большой набор элементов управления, и возможности по работе с мультимедиа, двухмерной и трехмерной графикой, декларативный способ описания интерфейса с помощью языка разметки FXML, возможность стилизации интерфейса с помощью CSS, интеграция со Swing и многое другое.   
> История JavaFX фактически началась в первой половине 2000-х годов, когда разработчик по имени Крис Оливер (Chris Oliver), будучи работником компании SeeBeyond, разработал для создания графических интерфейсов новый язык F3 (Froms Follows Functions). Впоследствии в 2005 году SeeBeyond была приобретена компанией Sun Microsystems (которая на тот момент развивала язык Java до покупки компанией Oracle). F3 был переименован в JavaFX, а Крис Оливер продолжил работу над новой платформой уже в рамках компании Sun. И в мае 2007 года Sun Microsystems публично анонсировала новую платформу для создания графических приложений. А 4 декабря 2008 года вышел JavaFX 1.0 SDK.   
> После приобретения Sun Microsystems компанией Oracle в 2010 году была анонсирована, а в 2011 году вышла в релиз версия JavaFX 2.0. В первой версии JavaFX фактически представлял скиптовый язык. Во второй версии был полностью изменен подход. Скриптовый язык был убран, а платформа была полностью переписана фактически с нуля. Теперь создавать приложения можно было с помощью любого языка, который поддерживала JVM. Были добавлены новые API, интеграция со Swing и много других вещей.  
> Следующими важными вехами в развитии платформы стали версии JavaFX 8 и особенно JavaFX 9, которая вышла в сентябре 2017 года вместе с Java 9 и привнесла в платформу модульность. И если раньше JavaFX поставлялась вместе с Java SE, то сейчас JavaFX отделена от основной функциональности Java SE и используется как отдельный модуль. Последняя версия фреймворка - JavaFX 12 - вышла в марте 2019 года.  
> На данный момент JavaFX представляет предпочтительный способ для создания графических приложений с помощью языка Java, который пришел на смену AWT и Swing. Также стоит отметить, что для работы с JavaFX вместо Java теоретически можно использовать любой язык программирования, который поддерживается JVM.

> **Класс Application и жизненный цикл приложения** 
> ```
> import javafx.stage.Stage;
> import javafx.scene.Scene;
> import javafx.scene.Group;
> import javafx.scene.text.Text;
> public class Main extends Application{
> public static void main(String[] args) {
> Application.launch(args);
> }
> @Override
> public void start(Stage stage) {
> // установка надписи
> Text text = new Text("Hello from JavaFX!");
> text.setLayoutY(80);    // установка положения надписи по оси Y
> text.setLayoutX(100);   // установка положения надписи по оси X
> Group group = new Group(text);
> Scene scene = new Scene(group);
> stage.setScene(scene);
> stage.setTitle("First Application");
> stage.setWidth(300);
> stage.setHeight(250);
> stage.show();
> }
> }
>```
> Вкратце разберем этот класс. Главный класс приложения JavaFX должен наследоваться от класса javafx.application.Application. Этот класс имеет один абстрактный метод, который нам нужно реализовать:  
> public void start(Stage stage) {}

> **Stage** 
> В этот метод в качестве параметра передается объекта Stage, который представляет пользовательский интерфейс. Например, на десктопах Stage будет представлять графическое окно. При запуске приложения, когда среда JavaFX будет вызывать данный метод и передавать в него объект Stage.   
> Что нам нужно для создания графического интерфейса? Прежде всего нам нужны различные визуальные элементы, например, кнопки, текстовые поля, списки, изображения и так далее. JavaFX предоставляет большой набор встроенных визуальных элементов. В данном случае мы используем визуальный компонент javafx.scene.text.Text, который представляет простую текстовую надпись. При создании элемента Text мы можем передать ему выводимый текст, а также настроить его положение с помощью его методов:
> ```
> Text text = new Text("Hello from JavaFX!");     // создание надписи 
> text.setLayoutY(80);        // установка положения надписи по оси Y 
> text.setLayoutX(100);   // установка положения надписи по оси X
> ```

> **Scene
> Все визуальные элементы, которые мы хотим отобразить в Stage, помещаются в объект javafx.scene.Scene или на сцену. Scene - это контейнер верхнего уровня для всех графических элементов. Однако напрямую в Scene объект Text мы поместить не можем. Класс Scene предусматривает установку корневого элемента или контейнера, который содержит все остальные элементы. 
> Таким образом, вначале элемент Text помещается в элемент Group, который представляет контейнер для группы элементов. Затем элемент Group устанавливается в качестве корневого элемента Scene. И в конце элемент Scene устанавливается для объекта Stage. 
> ```
> Group group = new Group(text);  // создание и установка группы элементов 
> Scene scene = new Scene(group);     // создание сцены 
> stage.setScene(scene);                  // установка сцены для объекта Stage 
> ```
> В конце метода start мы можем настроить объект Stage, например, задать заголовок окна, а также его размеры:
> ```
> stage.setTitle("First Application"); // установка заголовка окна 
> stage.setWidth(300);        // установка ширины окна 
> stage.setHeight(250);       // установка длины окна 
> stage.show();               // отображаем окно на экране устройства 
> ```
> С помощью метода show объект Stage отображается на экране устройства. 
> Но класс Main, как и всякий главный класс приложения Java, начинает свою работу с метода main. И в методе, чтобы запустить само приложение JavaFX, представленное классом Application, вызывается метод launch():
> ```
> public static void main(String[] args) {
> ```

10. Графические элементы. Класс Node. Взаимодействие с пользователем и обработка событий. 
> **Графические элементы**  
> Все графические элементы, которые используются в объекте Scene и добавляются в Scene Graph, должны представлять класс javafx.scene.Node или иначе узел. Все встроенные классы визуальных графических элементов или узлы, например, кнопки, текстовые поля и другие, наследуется от класса Node.   
> При этом одни узлы Node могут содержать несколько других узлов Node. Например, класс Parent наследуется от Node, но при этом сам может содержать другие узлы Node.

> **Класс Node**  
> > Вкратце рассмотрим эту иерархию. Основные классы, которые наследуются от класса Node:
> - javafx.scene.shape.Shape: является базовым классом для создания геометрических двухмерных примитивов (например, линия, прямоугольник, эллипс) 
> - javafx.scene.shape.Shape3D: является базовым классом для создания трехмерных объектов 
> - javafx.scene.canvas.Canvas: представляет полотно для отрисовки различного содержимого 
> - javafx.scene.image.ImageView: элемент для отображения изображений 
> - javafx.scene.media.MediaView: элемент для работы с мультимедиа 
> - javafx.embed.swing.SwingNode: элемент для встраивания содержимого Swing в JavaFX 
> - javafx.scene.Parent: базовый класс для всех элементов, которые могут содержать другие элементы

> **Взаимодействие с пользователем и обработка событий**
> Для взаимодействия с пользователем в JavaFX используется событийная модель. В этой модели есть источник события - некоторый элемент управления, который генерирует событие, и есть один или несколько слушаетелей или обработчиков события, которые подписываются на событие. Когда элемент управления генерирует событие, то обработчик обрабатывает это событие.
> Базовым классом для всех событий является класс javafx.event.Event, который унаследован от класса java.util.EventObject. При генерации событии, например, при нажатии на кнопку, создается объект Event, через который передается информация о событии. В данном случае при нажатии на кнопку будет генерироваться событие типа javafx.event.ActionEvent (который наследуется от Event).   
> Для определения обработчика события используется функциональный интерфейс EventHandler.  
> Интерфейс EventHandler типизируется типом, который унаследован от класса Event и который по сути представляет событие. В нашем случае это класс ActionEvent.   
> Для прикрепления обработчика события EventHandler к событию элемента управления применяется метод btn.setOnAction(), в который передается реализация интерфейса EventHandler. В методе handle определяются действия, которые будут вызываться при нажатии на кнопку  
> Нередко вместо определения явной реализации интерфейса EventHandler применяются лямбда-выражения. Например, мы могли бы переписать метод btn.setOnAction() следуюшим образом:

11. Нововведения Java 7.0.
> 1. Структура языка  
>   1.1. Использование строк в операторе switch   
> Пример 33. 
> ```
> switch (param) {
> case "plain":
> System.err.println("bear");
> break;
> case "mountain":
> System.err.println("tiger");
> break;
> case "swamp":
> System.err.println("cockroach");
> break;
> case "forest": case "island":
> System.err.println("snake");
> break;
> }
> ```
>   1.2. Подчеркивание в числах  
> int one_million = 1_000_000;  
>   1.3. Multi-Catch  
> Пример 34.  
> ```
> try {
> ...// we are using reflection here
> } catch (ClassCastException e) {
> doSomethingClever(e);
> throw e;
> } catch(InstantiationException | NoSuchMethodException | InvocationTargetException e) {
> log(e);
> throw e;
> }
>```
>   1.4. оператор <> - diamond (брилиант)   
> List<String> strList = new ArrayList<>();
> 2. Библиотеки   
> • NIO2   
> Имеется полный доступ к файловой системе: можно писать в файл через потоки или каналы, перебирать, копировать, перемещать и удалять файлы, создавать ссылки, получать атрибуты, сравнивать пути, «подсматривать» за файловой системой.  
> • Concurrency  
> • Удобный фреймворк для распараллеливаемых задач Fork/Join  
> • Новый класс синхронизации Phaser (барьер, в дополнение к CyclicBarrier и CountDownLatch)  
> • Новый интерфейс TransferQueue (расширяет BlockingQueue, имплементирован в LinkedTransferQueue)  
> • Client features  
> • Nimbus LaF – новый кроссплатформенный look-and-feel   
> • JLayer – декоратор для swing-компонент   
> • XRender pipeline – использование ресурсов графических видеокарт для отрисовки Java2D для повышения производительности.   
> • новый API AWT (полупрозрачные и фигурные окна, смешивание "тяжелых" и "лёгких" компонент (HW/LW))  
> 3. Виртуальная Машина  
> • The DaVinci Machine project   
> Этот проект прототипирует ряд расширений для JVM, таким образом, что она может запускать приложения, написанные не на Java, с уровнем производительности, сравнимым с самой Java. Акцент делается на доработке существующего байт-кода и архитектуры выполнения с расширениями общего назначения для работы с отличными от Java языками.   
> • InvokeDynamic bytecode   
> Исполнение метода требовало точного имени метода, списка параметров и возвращаемого значения на этапе компиляции. Новая инструкция Байткода InvokeDynamic позволяет использовать позднее связывание для методов с помощью MethodHandler. При первом вызове метода находится метод и создаётся handler. Последующие вызовы его переиспользуют.

12. Нововведения Java 8.0.
> Java 
> - Ламбда-выражения; 
> - Ссылки на методы; 
> - Повторяемые аннотации; 
> - Аннотации на типы данных; 
> - Рефлексия для параметров методов; 
> - Методы по-умолчанию.
> Коллекции 
> - Новый API для потоков; 
> - Параллельная сортировка массивов; 
> - Улучшение производительности HashMaps.
> Компактные сборки Java 
> - Возможность создания профилей для платформы Java SE, которые включают в себя не всю платформу целиком, а некоторую ее часть. 
> Безопасность 
> - Новая реализация AccessController.doPrivileged, позволяющая устанавливать подмножество привелегий без необходимости проверки всех остальных уровней доступа; 
> - Password-based алгоритмы стали более устойчивыми; 
> - Добавлена поддержка SSL/TLS Server Name Indication (NSI) в JSSE Server; 
> - Улучшено хранилище ключей (KeyStore); 
> - Добавлен алгоритм SHA-224;
> Инструменты 
> - Добавлена команда jjs для использования нового JavaScript-движка Nashorn; 
> - Команда java может запускать JavaFX приложения; 
> - Добавлена команда jdeps для анализа .class-файлов.
> Интернационализация 
> - Добавлена поддержка Unicode 6.2.0; 
> - Добавлен новый API для Calendar и Locale; 
> - Новый API Date/Time; 
> - Новый движок JavaScript Nashorn;
> [N]IO 
> - Улучшена производительность конструктора java.lang.String(byte[], *) и метода java.lang.String.getBytes(). 
> - Добавлен стандартный класс для работы с Base64; 
> - Добавлена поддержка беззнаковой арифметики; 
> - Удален мост JDBC-ODBC; 
> - Удален PermGen, изменен способ хранения мета-данных классов. 
> - Добавлено несколько новых классов для потокобезопасной работы с ConcurrentHashMap, Atomics, ForkJoinPool, Locks.
