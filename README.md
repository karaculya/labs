# Вопросы

## Вопросы к 8 лабе:

1. ORM. Достоинства и недостатки. Hibernate. Файл hibernate.cfg.xml. Пример. 
> ORM (Object-relational mapping) — это отображение объектов какого-либо объектно-ориентированного языка в структуры реляционных баз данных.
> 
> **Преимущества ORM**
> - Нет необходимости писать рутинные insert/update/delete/select для CRUD(create, read, update, delete) операций. 
> - Условия связи между объектами (строками таблиц) указываются декларативно в одном месте. 
> - Возможность использовать полиморфные запросы для иерархий классов. 
> - Высокая степень независимости от конкретной СУБД.
> 
> **Недостатки ORM**
> - Возможны проблемы с производительностью для сложных запросов на объектном SQL. 
> - Затрудняет использование специфических конструкций языка SQL конкретной СУБД. 
> - Потеря объектно-реляционного соответствия.
> 
> ORM-решением для языка Java является технология Hibernate, которая не только связывает Java классы с таблицами базы данных, но также предоставляет средства для автоматического построения запросов и извлечения данных и может значительно уменьшить время разработки, которое обычно тратится на ручное написание SQL и JDBC кода. Hibernate генерирует SQL вызовы и освобождает разработчика от ручной обработки результирующего набора данных и конвертации объектов.
> 
> Mapping (сопоставление, проецирование) Java-классов с таблицами БД осуществляется с помощью конфигурационных XML файлов или Java-аннотаций. Обеспечиваются возможности по организации отношений между классами «один-ко-многим» и «многие-ко-многим».
Для применения Hibernate на практике во-первых, необходимо описать XML файл, содержащий информацию о настройках связи с БД и о способе Mapping. Располагаться он должен в самом корне дерева классов.

**Файл hibernate.cfg.xml.**
 ```xml 
<hibernate-configuration>
    <session-factory>
        <!-- PostgreSQL connection settings -->
        <property name="connection.driver_class">org.postgresql.Driver</property>
 <property name="connection.url">jdbc:postgresql://localhost:5433/orm</property>
        <property name="connection.username">postgres</property>
        <property name="connection.password">sa</property>
      <property name="dialect">org.hibernate.dialect.PostgreSQLDialect</property>
        <property name="hbm2ddl.auto">update</property>

        <!-- Other hibernate settings -->
        <property name="show_sql">true</property>

        <!-- Annotated classes (Mapping from Annotations) -->
        <mapping package="ssau.lr8.model"/>
        <mapping class="ssau.lr8.model.Artist"/>
        <mapping class="ssau.lr8.model.Album"/>
        <mapping class="ssau.lr8.model.Composition"/>

        <!-- Mapping from configuration file (as an alternative to annotations) -->
        <!--<mapping resource="mapping.hbm.xml"/>-->
    </session-factory>
</hibernate-configuration>
 ```
> - connection.driver_class Показывает класс драйвера, который используется для соединения с базой данных. 
> - connection.url –URL для соединения с базой данных. 
> - connection.username – логин к базе данных. 
> - connection.password – пароль к базе данных. 
> - dialect – т.к. Hibernate может работать с разными базами данных, и каждая имеет какие-то особенности (генерация первичного ключа, страничный вывод, функции), нам надо указать, с какой базой мы работаем. В данном случае у нас PostgreSQL, что мы и указываем. 
> - hbm2ddl.auto - свойство, которое указывается что нужно сделать со схемой БД при инициализации. Может принимать такие значения:  
> **update** - сверяет схему БД с имеющимися конфигурациями классов, если мы внесли какие-то изменения, они автоматически заносятся в БД. При этом данные, которые были занесены в базу не изменятся - даже, если мы решили удалить некоторые поля из таблицы, они все одно останутся;   
> **create** - каждый раз при запуске приложения, схема БД будет создаваться заново. Все данные, которые были занесены раньше, будут удалены;  
> **create-drop** - каждый раз при запуске приложения, схема БД будет создаваться заново, а при завершении - удаляться. Все данные, которые были занесены во время работы приложения, будут удалены по завершению приложения;  
> **validate** - при инициализации будет совершена проверка соответствуют ли конфигурации классов и схема БД. Если мы внесли изменение в конфигурацию какого-то класса, а схема в БД не была изменена, выбросится исключение;  
> **show_sql** – данное свойство указывает, будут ли выводится SQL-запросы, которые генерит Hibernate на консоль. В процессе отладки это бывает очень удобно. 
> - тэг – mapping. Он используется для перечисления всех классов, которые имеют связь с базой данных. Т.е. если вы хотите использовать какой-то класс для связи с какой-то таблицей, вы должны его здесь указать.
2. Servlet, Servlet container, Distributed servlet container, Servlet context, Servlet mapping. Жизненный цикл сервлетов. Особенности сервлетов. Объекты запроса и отклика. HTTP Servlet. Пример сервлета. Поддержка сессий. Общий дескриптор развёртывания web.xml. Фильтрация. 
> **Servlet (сервлет)** – это класс на Java, расширяющий возможности сервера, к которому происходят обращения в рамках модели «запрос-отклик». Теоретически может поддерживать любой тип запросов, но чаще всего используются HTTP-сервлеты.  
> **Servlet container (контейнер сервлета)** - контейнер, обеспечивающий сетевые службы, при помощи которых посылаются запросы и ответы, декодируются запросы и форматируются ответы. Все контейнеры сервлетов должны поддерживать HTTP протокол, но могут также поддерживать дополнительные протоколы, например, HTTPS.  
> **Distributed servlet container (распределенный контейнер сервлета)** - контейнер сервлета, запускающий Web-приложения, которые помечены как распределенные и выполняются на нескольких виртуальных машинах Java. При этом виртуальные машины могут быть запущены, как на одном, так и на разных компьютерах.  
> **Servlet context (контекст сервлета)** - объект, содержащий представление (вид) Web-приложения, в котором запущен сервлет. Используя контекст, сервлет может вести журнал событий, получать URL-ссылки на ресурсы, а также устанавливать и хранить атрибуты, которые могут использоваться другими сервлетами в приложении.  
> **Servlet mapping (отображение сервлета)** - определяет связь между структурой URL и сервлетом. Используется для отображения запросов в сервлеты. Если контейнер, обрабатывающий запрос, является JSP-контейнером, то неявно отображается URL, содержащий расширение .jsp.
> 
> **Жизненный цикл сервлета**
> - Если экземпляр сервлета не существует, то контейнер:
>   - загружает класс сервлета; 
>   - создает его экземпляр; 
>   - вызывает метод init().
> - При получении запроса вызывается метод service(), которому передаются объекты запроса и отклика.
> - Если контейнеру требуется удалить объект сервлета, то вызывается метод destroy().
>
> **Особенности сервлетов**
> - Существуют механизмы реагирования на события, связанные с деятельностью сервлетов в приложении:
>   - javax.servlet.СобытиеListener 
>   - javax.servlet.СобытиеEvent
> - Для обработки события требуется:
>   - написать класс, реализующий интерфейс. 
>   - снабдить этот класс аннотацией @WebListener (пакет javax.servlet.annotation).
> - Требуется учитывать то, что сервлет является разделяемым ресурсом и работает с разделяемыми ресурсами. 
> - Не следует использовать поля класса для хранения состояния, а особенно для передачи состояния между вызовами.
>
> **Объект запроса**
> - Реализует интерфейс javax.servlet.ServletRequest. 
> - Позволяет узнать характеристики запроса, в том числе значения параметров:
>   - String getParameter(String name)
>   - Enumeration getParameterNames()
>   - и ряд других методов
> - Позволяет получить доступ к потоку запроса:
>   - ServletInputStream getInputStream()
>   - BufferedReader getReader()
>   - Можно вызвать только один из этих двух методов
> - Позволяет получить параметры запроса
>   - int getContentLength()
>   - String getContentType()
>   - String getProtocol()
>   - и т.д.
>   
> **Объект отклика**
> - Реализует интерфейс javax.servlet.ServletResponse
> - Основные методы:
>   - ServletOutputStream getOutputStream()  
>   Далее для вывода используются обычные средства бинарного вывода
>   - PrintWriter getWriter()  
>   Далее для вывода используются обычные средства символьного вывода
>   - Можно вызвать только один из этих двух методов.
> - Позволяет установить параметры отклика
>   - Для установки типа отклика используется метод setContentType()
>   - Для установки кодировки используется метод setCharacterEncoding()
>   - Сбрасывает текущий буфер клиенту flushBuffer()
>   - Очищает буфер и сбрасывает статус reset()
>
> **HTTP Servlet**  
> - javax.servlet.http.HttpServlet - абстрактный класс, позволяющий создавать сервлеты, удобные для Web. 
> - Наследные классы должны переопределять хотя бы один из методов обработки запроса. 
> - Обычно это один из методов:
>   - void doGet(HttpServletRequest req, HttpServletResponse resp)
>   - void doPost(HttpServletRequest req, HttpServletResponse resp)
> - Классы снабжаются аннотацией @WebServlet.

**Пример сервлета.**
 ```java
import java.io.*;
import javax.servlet.*;
import javax.servlet.http.*;
import javax.servlet.annotation.*;
@WebServlet("/MyServlet.html")
public class MyServlet extends HttpServlet {
  protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {
    PrintWriter out = response.getWriter();
    try {
      out.print("<html><body>This is text document, which has "
                 + "<a href=\"other.html\">link</a>"
                 + " to another document</body></html>");
    }
    finally {
      out.close(); }
  }
}
```
> **Поддержка сессий.**
> - В HTTP-сервлетах в объектах запроса и отклика добавляются дополнительные методы. 
> - Среди них появляются методы работы с сессиями, включая работу с **Cookies** (англ. печенье) - небольшой фрагмент данных, отправленный веб-сервером и хранимый на компьютере пользователя. Веб-клиент (обычно веб-браузер) всякий раз при попытке открыть страницу соответствующего сайта пересылает этот фрагмент данных веб-серверу в составе HTTP-запроса. Применяется для сохранения данных на стороне пользователя, на практике обычно используется для аутентификации пользователя, хранения персональных предпочтений и настроек пользователя, отслеживания состояния сеанса доступа пользователя, ведения статистики о пользователях. 
> - Для передачи значений между запросами можно использовать атрибуты сессии.
>   - HttpSession.getAttribute(String name)
>   - HttpSession.setAttribute(String name, Object value)
>   - И ряд других методов
> Пример:
```java
public class CashierServlet extends HttpServlet {
  public void doGet (HttpServletRequest request,
                     HttpServletResponse response)
                     throws ServletException, IOException {
    // Get the user's session and shopping cart
    HttpSession session = request.getSession();
    ShoppingCart cart = (ShoppingCart)session.getAttribute("cart");
    //...
  }
}
out.println("<a href=\"" +
response.encodeURL(request.getContextPath() +
"/bookcatalog") + "\">");
```

> Общий дескриптор развёртывания web.xml.
> - Определяет параметры развёртывания web-приложения в контейнере. 
> - Некоторые из этих параметров даже не могут быть указаны с помощью аннотаций классов, т.к. относятся к web-приложению в целом. 
> - Указанные в дескрипторе параметры перекрывают параметры, указанные с помощью аннотаций классов.
> Пример. Дескриптор развертывания web.xml
```xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app version="3.0" xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd">
    <listener>
        <listener-class>org.tempuri.MyListner</listener-class>
    </listener>
    <servlet>
        <servlet-name>MyServlet</servlet-name>
        <servlet-class>org.tempuri.MyServlet</servlet-class>
    </servlet>
    <servlet-mapping>
        <servlet-name>MyServlet</servlet-name>
        <url-pattern>/MyServlet.html</url-pattern>
    </servlet-mapping>
    <welcome-file-list>
        <welcome-file>/MyServlet.html</welcome-file>
    </welcome-file-list>
</web-app>
```

> **Фильтрация**
> - Получаемые запросы и формируемые отклики могут быть подвергнуты фильтрации. 
> - API для классов фильтрации определен интерфейсами Filter, FilterConfig, FilterChain пакета javax.servlet. 
> - Включение фильтров осуществляется с помощью аннотации @WebFilter. 
> - Фильтры используются в основном для перехвата и изменения запросов и ответов от сервера. Рассмотрим случай, в котором проверяется сессия для каждого запроса пользователя, и если она верна, то только тогда пользователь может получить доступ к странице. Этого можно добиться путем проверки сессий на всех сервлет страницах (страницы JSP), которые запрашивают пользователи, или можно сделать это с помощью фильтра.
> Пример. Фильтр
```java
public class LogFilter implements Filter {
    public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException {
        HttpServletRequest request = (HttpServletRequest) req;
        String ipAddress = request.getRemoteAddr();
        System.out.println("IP " + ipAddress + ", Time " + new Date());
        chain.doFilter(req, res);
    }

    public void init(FilterConfig config) throws ServletException {
//Get init parameter
        String testParam = config.getInitParameter("test-param");
//Print the init parameter
        System.out.println("Test Param: " + testParam);
    }

    public void destroy() {
//add code to release any resource
    }
}
```
> - Метод init() используется для инициализации любого кода, который используется фильтром. Также отметим, что init() получит объект FilterConfig, который содержит различную информацию уровня фильтров, а также параметры инициализации, который передаются из web.xml (дескриптора развертывания). 
> - doFilter() фактически выведет информацию. Можно изменить этот метод и добавить код, который может изменить запрос / состояние сессии / ответ, добавить атрибут в запрос и т.д. 
> - destroy() вызывается контейнером, когда он хочет убрать мусор за фильтром. Это обычно делается, когда фильтр не используется в течение длительного времени и сервер хочет выделить память для других приложений.
> Пример. Маппинг фильтра в web.xml
```xml
<filter>
<filter-name>LogFilter</filter-name>
<filter-class>sample.LogFilter</filter-class>
<init-param>
<param-name>test-param</param-name>
<param-value>This parameter is for testing.</param-value>
</init-param>
</filter>
<filter-mapping>
<filter-name>LogFilter</filter-name>
<url-pattern>/*</url-pattern>
</filter-mapping>

```
3. JSP. Принцип работы, обработка ошибок, виды JSP, элементы JSP-страницы. Пример.
> **JSP** – это технология, которая упрощает создание web страниц с динамически изменяющимся (во время генерации страницы) содержимым.
```html
<html>
<body>
<p>HI<%= (request.getParameter("name")!=null) ? ", " + request.getParameter("name"): "" %>!!!</p>
</body>
</html>
```
> **JSP файл** – это текстовый документ, содержимое которого можно разбить на две части:
> - статический текст (каркас) – создается при помощи специальных редакторов. 
> - динамический (генерируемый во время выполнения страницы) – обычно пишется в среде разработки программирования.

> **Принципы работы:**
> - JSP-файл транслируется в файл java. 
> - Процесс трансляции управляется директивами (<%@ page […] %>). 
> - Полученный файл компилируется в класс сервлета. 
> - Далее с ним идет работа как с сервлетом. 
> - Конфигурация сервера может включать ряд настроек по работе с jsp-страницами.

> **Обработка ошибок**
> - Во время трансляции и компиляции
>   - поведение зависит от используемого сервера; 
>   - класс сервлета создан не будет.
> - Во время выполнения
>   - если для данной JSP страницы (или приложения) определена «страница на случай ошибки» (errorPage), то будет выведена указанная страница; 
>   - иначе – в зависимости от сервера и его настроек.
      
> **Виды JSP:**
> - JSP-страница
>   - Это страница из статических и динамических элементов. 
>   - Статическая часть имеет произвольный формат.
> - JSP-документ
>   - XML-файл, содержащий тэги особого вида. 
>   - Имеет ту же функциональность, что и JSP-страница, но требует представления в виде тэгов ряда элементов.

> **Элементы JSP-страницы**
> - Статический текст 
> - Элементы сценариев 
>   - Комментарии		**<%-- […] --%>**
>   - Объявления		**<%! […] %>**
>   - Скриптлеты		**<% […] %>**
>   - Выражения			**<%= […] %>**
>   - Директивы			**<%@ ? […]%>**
> - Стандартные объекты.

> Пример. JSP-страница с комментариями
```html
<html><body>
  Hello World!
  <%-- This is a JSP comment --%>
  <!-- This is a HTML comment -->
</body></html>
```
Фрагмент примерного кода сервлета
```java
out.write("<html><body>\n  Hello World!\n  ");
out.write("\n  <!-- This is a HTML comment -->"
           + "\n</body></html>\n");
```
4. Директива include. Стандартные объекты. Тэги <jsp:…>. Тэги <jsp:include>. Тэги <jsp:forward>. Взаимодействие с HTML-формами. Примеры. 
> **Директива include.** 
> - Предназначена для включения в формируемый отклик содержимого другого файла. 
> - Включение статическое: происходит на этапе трансляции. 
> - Включаться могут как статические, так и динамические ресурсы. 
> - Существует специальный вид JSP-страниц – JSP Fragments (JSPF).
    
Пример. Директива include. JSP-страницы
```html
Основная страница
<%@page contentType="text/html; charset=UTF-8"%>
<html><body>
<%@include file="WEB-INF/jspf/fragment.jspf" %>
</body></html>
Включаемая страница
<%@ page pageEncoding="UTF-8" %>
Some fragment text
```
Пример. Директива include.Примерный код сервлетов
```java
Основная страница
public final class index_jsp ... {
  private static java.util.Vector _jspx_dependants;
  static {
    _jspx_dependants = new java.util.Vector(1);
    _jspx_dependants.add("/WEB-INF/jspf/fragment.jspf");
  }
  public void _jspService(HttpServletRequest request,
    HttpServletResponse response)
    throws java.io.IOException, ServletException {
    ...
    out.write("<html><body>\n");
    out.write("Some fragment text\n");
    out.write("</body></html>\n");
    ...
}
```

> **Стандартные объекты.**
> - page  
    Ссылка на текущий объект (по сути – объект сервлета).
> - config  
    Имеет тип javax.servlet.ServletConfig, позволяет получить контекст сервлета и параметры сервлета. 
> - application   
    Имеет тип javax.servlet.ServletContext, определяет контекст сервлета. 
> - pageContext  
    Имеет тип javax.servlet.jsp.PageContext, определяет контекст jsp-страницы. 
> - session  
    Имеет тип javax.servlet.http.HttpSession, представляет текущую сессию.
> - request  
    Имеет тип javax.servlet.http.HttpServletRequest, представляет текущий запрос. 
> - response  
    Имеет тип javax.servlet.http.HttpServletResponse, представляет текущий отклик.
> - out  
    Имеет тип javax.servlet.jsp.JspWriter, представляет поток для вывода, по функциональности схож с классом PrintWriter.

> **Тэги <jsp:…>.**
> - Являются еще одним средством управления ходом трансляции страницы. 
> - В основном предназначены для формата JSP-документов.
> - Позволяют:
>   - Описывать теги и их составляющие.
>   - Перенаправлять обработку запросов.
>   - Работать с компонентами JavaBeans.
>   - Включать в код страницы обращения к апплетам.

> **Тэги <jsp:include>.**
> - <jsp:include page="inclPage">
> - Включает в страницу статический или динамический ресурс.
> - Включение происходит динамически, во время выполнения.

> **Тэги <jsp:forward>.**
> - <jsp:forward page="inclPage">
> - Передает обработку запроса другому ресурсу.
> - Могут быть указаны дополнительные параметры.

> **Взаимодействие с HTML-формами. Примеры.** 
> - Элементы HTML-управления должны находиться в форме.
> - Для формы указывается адрес для перехода.
> - Значения элементов ввода записываются в параметры запроса.
> - В новой странице значения элементов ввода автоматически не заполняются.
> - Элемент управления, активация которого привела к смене страницы, вносится в параметры запроса.

5. Недостатки раннего JSP. Основные идеи смены парадигмы. Expression Language. Виды выражений EL. Пример. Литералы, операторы, объекты доступа к другим объектам. Custom tags. Библиотеки тегов. JSP Standard Tag Library. Библиотеки JSTL. 
> **Недостатки раннего JSP.** 
> - Смешение Java-кода и тегов страницы.
> - Много «типовых» действий.
> - «Некомфортность» работы на Java в ходе обработки запросов из-за:
>   - Громоздкости кода.
>   - Необходимости знания особенностей преобразования в сервлет.

> **Основные идеи смены парадигмы.** 
> - Альтернативный язык Expression Language.
> - Использование библиотек тегов, особенно JSTL – JSP Standard Tag Library.
> - Ориентация на компоненты в смысле JavaBeans и использование понятия свойств.
> - Общие принципы остаются прежними.

> **Expression Language.**
> - Является альтернативой выражениям и скриптлетам.
> - Динамическое чтение данных из:
>   - JavaBeans-компонентов.
>   - Неявных объектов.
>   - Различных структур данных.
> - Динамическая запись данных в:
>   - Формы.
>   - JavaBeans-компоненты.
> - Вызов статических и публичных методов.
> - Динамическое выполнение простых операций.

> **Виды выражений EL.** 
> - По моменту вычисления:
>   - Немедленное вычисление.
>   - Отложенное вычисление.
> - По цели выражения:
>   - Обращение к данным.
>   - Вызов метода.
> - По режиму доступа:
>   - Только чтение.
>   - Чтение и запись данных.  
>
> **Немедленное и отложенное вычисление**
> - Немедленное вычисление (JSP и JSF):
>   - ${ выражение } 
>   - Позволяет лишь получить значение выражения.
> - Отложенное вычисление (JSF):
>   - #{ выражение } 
>   - Выражение может использоваться различным образом в разные моменты жизненного цикла. 
>   - Позволяет не только получать значения, но и записывать их (в т.ч. для свойств бинов).
> 
> **Применение выражений с немедленным вычислением**
> - Выражения EL могут применяться:
>   - в статическом тексте
>   - в качестве значений атрибутов тегов
>
**Пример.**
```html
<some:tag>
    some text ${expr} some text
</some:tag>
<some:tag value="${expr}"/>
<some:tag value="some${expr}${expr}text${expr}"/>
```
> **Литералы в выражениях**
> - Логические true, false
> - Целочисленные 136
> - С плавающей точкой 3.14, 1.0e10
> - Строковые “string”
> - Ссылочные null
>
> **Операторы в выражениях**
> - Доступ к элементам []
> - Операторные скобки ()
> - Унарные -  not  !  Empty (Empty А возвращает true, если А – ноль)
> - Арифметические *  /  div  %  mod + -
> - Сравнение <  >  <=  >= lt  gt  le  ge  ==  !=  eq  ne
> - Логические && and ||  or ? :

> **Custom tags.** 
> - Определяются пользователем и описывают часто используемые операции.
> - Описываются и распространяются в виде библиотек тегов, определяющих семейства тегов и содержащих объекты, реализующие теги.
> - Для использования тегов необходимо:
>   - Объявить библиотеку тегов
>   - Сделать ее доступной для web-приложения
```html
<prefix:tag attr1="value" ... attrN="value" />
<prefix:tag attr1="value" ... attrN="value" >
body
</prefix:tag>
```
> **Библиотеки тегов.** 
> - Библиотеки тегов описываются в tld-файлах
> - Библиотеки могут быть
>   - публичными и храниться в сети
>   - локальными и храниться в каталоге WEB-INF
> - Для подключения библиотеки необходимо использовать директиву taglib
```
<%@ taglib prefix="tlt" uri="/WEB-INF/iterator.tld"%> 
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core"%>
```
> Обработка custom tags 
> - В процессе компиляции jsp-страницы теги будут преобразовываться в java-код в соответствии с описанием в библиотеке тегов. 
> - Если соответствующая библиотека не была подключена, относящиеся к ней теги будут трактоваться как статическая часть jsp-страницы и просто выводиться в отклик.

> **JSP Standard Tag Library.**
> - Библиотека включает в себя набор тегов, функциональность которых часто используется в web-приложениях.
> - Эти теги должны обрабатываться единообразно в рамках всех контейнеров.
> - Это позволяет:
>   - избежать использования различных библиотек.
>   - единообразно организовывать JSP-страницы .

> **Библиотеки JSTL.** 
> - JSTL поставляется в виде набора библиотек:
>   - Различные направления функциональности
>   - Различные пространства имен
> - Библиотеки и соответствующие пути
>   - Core http://java.sun.com/jsp/jstl/core
>   - XML http://java.sun.com/jsp/jstl/xml
>   - Internationalization	http://java.sun.com/jsp/jstl/fmt
>   - Database http://java.sun.com/jsp/jstl/sql
>   - Functions http://java.sun.com/jsp/jstl/functions

6. AJAX.
> Ajax – это аббревиатура, означающая "Асинхронный JavaScript и XML" (Asynchronous JavaScript and XML). Основное назначение Ajax состоит в предоставлении веб-приложению возможности эффективной обработки взаимодействия между пользователем и веб-страницей, при этом значительно снижаются требования к обновлению или полной перезагрузке страницы при каждом взаимодействии с пользователем. Такой подход предоставляет широкие возможности при использовании браузера (аналогичные возможностям настольного приложения или веб-приложения на основе подключаемого модуля). Обработка взаимодействия Ajax осуществляется асинхронно в фоновом режиме. Благодаря этому пользователь может продолжать работу со страницей. Взаимодействие Ajax инициируется посредством кода JavaScript. После выполнения взаимодействия Ajax код JavaScript обновляет исходный текст HTML для страницы. Изменения вносятся немедленно без необходимости обновления страницы. Взаимодействия Ajax могут использоваться для выполнения таких задач, как проверка правильности формата вводимых записей на основе серверной логики (непосредственно во время их ввода пользователем), извлечение подробных данных из сервера, динамическое обновление данных на странице и передача элементов форм страницы.
>
> Для того, чтобы осуществлять обмен данными, на странице должен быть создан объект XMLHttpRequest, который является своеобразным посредником между Браузером пользователя и сервером (рис. 30). С помощью XMLHttpRequest можно отправить запрос на сервер, а также получить ответ в виде различного рода данных. 
> 
> Обмениваться данными с сервером можно двумя способами. Первый способ — это GET-запрос. В этом запросе вы обращаетесь к документу на сервере, передавая ему аргументы через сам URL. Не рекомендуется делать GET-запросы к серверу с большими объемами данных. Для этого существует POST-запрос.
>
> Клиентская часть, написанная на Javascript, должна обеспечивать необходимую функциональность для безопасного обмена с сервером и предоставлять методы для обмена данными любым из вышеперечисленных способов. Серверная часть должна обрабатывать входные данные, и на основе их генерировать новую информацию (например, работая с базой данных), и отдавать ее обратно клиенту. Например, для запроса информации с сервера можно использовать обычный GET-запрос с передачей нескольких и небольших по размеру параметров, а для обновления информации, или добавления новой информации потребуется использовать уже POST-запрос, так как он позволяет передавать большие объемы данных.
> 
> Ответ от сервера может быть не только XML, как следует из названия технологии. Помимо XML, можно получить ответ в виде обычного текста, или же JSON (Javascript Object Notation). Если ответ был получен простым текстом, то его можно сразу вывести в контейнер на странице. При получении ответа в виде XML, обычно происходит обработка полученного XML документа на стороне клиента и преобразование данных к (X)HTML. При получении ответа в формате JSON клиент должен лишь выполнить полученный код для получения полноценного объекта Javascript. 
>
> **Методы объекта XMLHttpRequest**
> - abort() — отмена текущего запроса к серверу.
> - getAllResponseHeaders() — получить все заголовки ответа от сервера.
> - getResponseHeader(«имя_заголовка») — получить указаный заголовок.
> - open(«тип_запроса»,«URL»,«асинхронный»,«имя_пользователя»,«пароль») — инициализация запроса к серверу, указание метода запроса. Тип запроса и URL — обязательные параметры. Третий аргумент — булево значение. Обычно всегда указывается true или не указывается вообще (по умолчанию — true). Четвертый и пятый аргументы используются для аутентификации (это очень небезопасно, хранить данные об аутентификации в скрипте, так как скрипт может посмотреть любой пользователь).
> - send(«содержимое») — послать HTTP запрос на сервер и получить ответ.
> - setRequestHeader(«имя_заголовка»,«значение») — установить значения заголовка запроса.
>
> **Создание объекта XMLHttpRequest**
> Как уже говорилось выше, создание данного объекта для каждого типа браузера — уникальный процесс. 
> 
> Например, для создания объекта в Gecko-совместимых браузерах, Konqueror`е и Safari, нужно использовать следующее выражение:
> 
> var Request = new XMLHttpRequest(); 
>
> А для Internet Explorer`а используется следующее:
>
> var Request = new ActiveXObject("Microsoft.XMLHTTP"); 
> 
> Либо 
>
> var Request = new ActiveXObject("Msxml2.XMLHTTP"); 
>
> Теперь, чтобы добиться кроссбраузерности, необходимо сложить все функции в одну:
>
> После всего этого можно создавать данный объект и не беспокоится за работоспособность на популярных браузерах. Но создать объект можно в разных местах. Если создать его глобально, то в определенный момент времени возможен будет только один запрос к серверу. Можно создавать объект в сякий раз, как происходит запрос к серверу (это почти полностью решит проблему).**Запрос к серверу**
> 
> Алгоритм запроса к серверу выглядит так:
> - Проверка существования XMLHttpRequest.
> - Инициализация соединения с сервером.
> - Посылка запроса серверу.
> - Обработка полученных данных.
> 
> Предположим, что существует веб-страница, на которой пользователь может выполнять поиск информации о композиторах. Эта страница содержит поле, в которое вводится имя композитора. В примере приложения для поля ввода может использоваться функция автозавершения. Другими словами, пользователь может ввести часть имени композитора, после чего веб-приложение предложит варианты полного имени, перечислив всех композиторов, чьи имена или фамилии начинаются с введенных символов. Таким образом, пользователь может не помнить полное имя композитора, однако функция автозавершения обеспечит быстрый интуитивный доступ к требуемой информации.
> 
> Реализация функции автозавершения в поле поиска может служить примером возможностей, предоставляемых Ajax. Ajax использует объект XMLHttpRequest для асинхронной передачи запросов и ответов между клиентом и сервером. На рисунке 30 представлена блок-схема операций связи, происходящих между клиентом и сервером.
>
> Для описания потока операций на блок-схеме можно использовать следующие действия.
> - Пользователь инициирует событие, например, отпускает клавишу при наборе имени. Это приводит к вызову функции JavaScript, которая инициализирует объект XMLHttpRequest.
> - Объект XMLHttpRequest настроен с учетом параметра запроса, который включает идентификатор элемента управления, инициировавшего событие, а также произвольное значение, введенное пользователем. Затем объект XMLHttpRequest выполняет асинхронный запрос к веб-серверу.
> - На веб-сервере осуществляется обработка этого запроса с использованием соответствующего объекта, например сервлета или прослушивающего процесса. Из хранилища данных извлекаются необходимые данные и подготавливается ответ, содержащий данные в форме документа XML.
> - Наконец, объект XMLHttpRequest получает данные XML с использованием функции ответного вызова, выполняет их обработку и обновляет модель DOM (Document Object Model, объектная модель документов) HTML для отображения страницы, содержащей новые данные.
> 
> Способ создания варианта автозаполнения путем выполнения потока операций процесса, показанного на рисунке выше, состоит в следующем: сначала на стороне клиента создаются файлы для страницы представления данных и функции, необходимые для генерации объекта XMLHttpRequest. Затем выполняется настройка на стороне сервера, заключающаяся в создании хранилища данных и бизнес-логики с использованием технологий на основе Java. Наконец, на стороне клиента реализуется функция обратного вызова callback() и другие функциональные возможности JavaScript, необходимые для обновления DOM HTML.