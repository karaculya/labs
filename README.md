# Вопросы
## Вопросы к 3 лабе:
1. Проблемы однопоточного подхода. Особенности многопоточности.
  > - Монопольный захват задачей процессорного времени.
  > - Смешение логически несвязанных фрагментов кода.
  > - Попытка их разделения приводит к возникновению в программе новых систем.  
  > Реализацию многопоточной архитектуры проще всего представить себе для системы, в которой есть несколько центральных вычислительных процессоров. В этом случае для каждого из них можно выделить задачу, которую он будет выполнять. В результате несколько задач будут обслуживаться одновременно.
  Однако возникает вопрос – каким же тогда образом обеспечивается многопоточность в системах с одним центральным процессором, который в принципе выполняет лишь одно вычисление в один момент времени? В таких системах применяется процедура квантования времени (time-slicing). Время разделяется на небольшие интервалы (кванты времени). Во время одного кванта обрабатывается один поток команд. Перед началом каждого интервала принимается решение, какой именно поток выполнения будет обрабатываться на протяжении этого кванта времени. За счет частого переключения между задачами эмулируется многопоточная архитектура, т.е. создается иллюзия одновременности выполнения.
  На самом деле, как правило, и для многопроцессорных систем применяется процедура квантования времени. Дело в том, что даже в мощных серверах приложений процессоров не так много (редко бывает больше десяти), а потоков исполнения запускается, как правило, гораздо больше. Т.о. в многопроцессорной системе поток не занимает монопольно один процессор. 
2. Использование класса Thread.
  > Поток выполнения в Java представляется экземпляром класса Thread. Для того, чтобы написать свой поток исполнения необходимо наследоваться от этого класса и переопределить метод run(). Стандартная реализация метода run не предполагает выполнения каких бы то ни было действий.
  ```      
  //Объявление:
  public class <Имя класса> extends Thread {
    public void run() {
      // Действия, выполняемые потоком
    }
  }
  //Запуск:
  <Имя класса> t = new <Имя класса>();
  t.start();
  ```
  > Метод run() содержит действия, которые должны исполняться в новом потоке исполнения. Чтобы запустить его, необходимо создать экземпляр класса-наследника, и вызвать унаследованный метод start(), который сообщает виртуальной машине, что необходимо запустить новый поток исполнения и начать в нем исполнять метод run().
  Вызов start для каждого потока может быть осуществлен только один раз – повторное обращение приводит к выбрасыванию исключения типа IllegalThreadsStateException.
  Потоку разрешено присвоить имя – либо с помощью аргумента String, переданного конструктору, либо посредством вызова метода setName. Текущее значение имени потока можно получить с помощью метода getName. Имена потоков служат только для удобства программиста (исполняющей системой они не используются), но поток должен обладать именем, и если оно не задано, исполняющая система генерирует имена в соответствии с неким простым правилом, например, thread_1, thread_2 и т.д.
  Ссылку на объект Thread текущего выполняемого потока можно получить с помощью статического метода Thread.currentThread. Во время работы программы текущий поток существует всегда, даже если вы не создавали потоки явно – метод main активизируется с помощью потока, создаваемого исполняющей системой.
3. Использование интерфейса Runnable. 
  > Описанный подход обладает одним недостатком. Поскольку в Java отсутствует множественное наследование, требование наследоваться от Thread может привести к конфликту. Если еще раз посмотреть на приведенный выше пример, то станет понято, что наследование производилось только с целью переопределения метода run(). Поэтому предлагается более простой способ создать свой поток исполнения. Достаточно реализовать интерфейс Runnable, в котором объявлен только один метод - уже знакомый void run(). Запишем пример, приведенный выше, с помощью этого интерфейса:
  ```
  //Объявление:
  public class <Имя класса> implements Runnable {
    public void run() {
      // Действия, выполняемые потоком
    }
  }
  //Запуск:
  Runnable r = new <Имя класса>();
  Thread t = new Thread(r);
  t.start();
  ```
  > Подчеркнем, что Runnable не является полной заменой классу Thread, поскольку создание и запуск самого потока исполнения возможно только через метод Thread.start().
4. Управление потоками. Нерекомендуемые действия над потоками. Прерывание потока. 
  > - void start() - Запускает выполнение потока 
  > - void stop() - Прекращает выполнение потока 
  > - void suspend() - Приостанавливает выполнение потока 
  > - void resume() - Возобновляет выполнение потока 
  > - static void sleep(long millis) - Останавливает выполнение потока как минимум на millis миллисекунд 
  > - static void yield() - Приостанавливает выполнение потока, предоставляет возможность выполнять другие потоки 
  > - void join() - Ожидает завершения указанного потока
5. Группы потоков. Операции в группе потоков. 
  > Каждый поток находится в группе. Группа указывается при создании потока. Если группа не была указана, то поток помещается в ту же группу, где находится поток, породивший его. Группы потоков образуют дерево, корнем служит начальная группа. Поток не имеет доступа к информации о родительской группе. Изменение параметров и состояния группы влияет на все входящие в нее потоки.
  ```
  //Создание группы:
  //Без явного указания родительской группы
  ThreadGroup group1 = new ThreadGroup("Group1");
  //С явным указанием родительской группы
  ThreadGroup group2 = new ThreadGroup(group1,  "Group2");
  //Создание потока:
  //Без явного указания группы
  MyThread t = new MyThread("Thread1");
  //С явным указанием группы
  MyThread t = new MyThread(group2, "Thread2");
  ```
  **Операции в группе потоков**
  - int activeCount() - Возвращает приблизительное количество действующих (активных) потоков группы, включая и те потоки, которые принадлежат вложенным группам. Количество нельзя считать точным, т.к. в момент выполнения метода оно может измениться – одни потоки «умирают», другие – создаются. 
  - int enumerate(Thread[] list) - Заполняет массив list ссылками на объекты активных потоков группы и возвращает количество сохраненных ссылок. Также учитываются потоки, относящиеся ко всем вложенным группам. 
  - int activeGroupCount() - Возвращает количество групп, включая вложенные. 
  - int enumerate(ThreadGroup[] list) - Заполняет массив list ссылками на объекты вложенных групп потоков. 
  - void interrupt() - Прерывает выполнение всех потоков в группе
6. Приоритеты потоков.
   > Приоритет – количественный показатель важности потока. Недетерминированно воздействует на системную политику упорядочивания потоков. Базовый алгоритм не должен зависеть от схемы расстановки приоритетов потоков. В Java потокам можно назначать приоритеты. Для этого в классе Thread существуют методы getPriority() и setPriority(), а также объявлены три  
   **Константы:**
   > - static int MAX_PRIORITY 
   > - static int MIN_PRIORITY 
   > - static int NORM_PRIORITY  
   Их значения описывают максимальное, минимальное и нормальное (по умолчанию) значения приоритета.  
   **Методы потока:**
   > - final int getPriority() – возвращает ранее заданное значение приоритета выполнения для текущего потока. 
   > - final void setPriority(int newPriority) – устанавливает приоритет выполнения для текущего потока.   
   **Методы группы потоков:**
   > - final int getMaxPriority() – возвращает ранее заданное значение верхней границы приоритетов выполнения для текущей группы потоков. 
   > - final void setMaxPriority(int maxPri) – устанавливает верхнюю границу приоритетов выполнения для текущей группы потоков.
7. Демон-потоки. Пример. Демон-группы потоков. 
  > **Демон-потоки** позволяют описывать фоновые процессы, которые нужны только для обслуживания основных потоков выполнения и не могут существовать без них. Уничтожаются виртуальной машиной, если в группе не осталось не-демон потоков.
  > - void setDaemon(boolean on) - устанавливает вид потока. Вызывается до запуска потока. 
  > - boolean isDaemon() - возвращает вид потока:
  true – демон, false – обычный.
  >
  > **Демон-группа** автоматически уничтожаются при останове последнего ее потока или уничтожении последней подгруппы потоков.
  > - void setDaemon(boolean on) - устанавливает вид группы. 
  > - boolean isDaemon() - возвращает вид группы: true – демон, false – обычная.
8. Совместное использование ресурсов. Характерные ошибки. 
  > При многопоточной архитектуре приложения возможны ситуации, когда несколько потоков будут одновременно работать с одними и теми же данными, используя их значения и присваивая новые. В таком случае результат работы программы становится невозможным предопределить, глядя только на исходный код. *Финальные значения переменных будут зависеть от случайных факторов, исходя из того, какой поток какое действие успел сделать первым или последним.* Отсюда следует возможность некорректной работы алгоритма, возникновения исключительных ситуаций.
  >
  > Решением проблемы является применение **механизма блокировки объекта**:  
  > - Только один поток в один момент времени может установить блокировку на некоторый объект. 
  > - Попытка блокировки уже заблокированного объекта приводит к останову потока до момента разблокирования этого объекта. 
  > - Наличие блокировки не запрещает всех остальных действий с объектом.
  >
  > **Характерные ошибки**:
  > - Отсутствие синхронизации. 
  > - Необоснованная длительная блокировка объектов. 
  > - Взаимная блокировка (deadlock). Если один поток заблокировал один ресурс, и пытается заблокировать второй, а другой поток заблокировал второй и пытается заблокировать первый, то такие потоки уже никогда не выйдут из состояния ожидания. В Java нет никаких средств распознавания или предотвращения ситуаций deadlock. Также нет способа перед вызовом синхронизированного метода узнать, заблокирован ли уже объект другим потоком. Программист сам должен строить работу программы таким образом, чтобы неразрешимые блокировки не возникали. 
  > - Возникновение монопольных потоков. 
  > - Нерациональное назначение приоритетов.
9. volatile. 
  > Рассмотрим пример.
  ```
  curentValue = 5;
  for(;;){
  display.showValue(currentValue);
  Thread.sleep(1000);
  }
  ```
  > Если метод showValue сам по себе не обладает возможностью изменения значения curentValue, компилятор может предположить, что внутри цикла for это значение можно трактовать как неизменное, и использовать одну и ту же константу 5 на каждой итерации цикла при вызове showValue. Но если содержимое поля curentValue в ходе выполнения цикла подвержено обновлению посредством других потоков, предположение компилятора окажется неверным.
  Преодолеть проблему может соответствующим способом оформленный синхронизированный код. Однако существует альтернативный вариант решения проблемы – объявление поля можно снабдить модификатором volatile. Этот признак свидетельствует о том, что значение поля может быть изменено в любой непредсказуемый момент. Если объявить curentValue как volatile, компилятор будет вынужден, выполняя каждую итерацию цикла, заново перечитывать значение переменной. *Метод, выполняющий считывание содержимого переменной, обозначенной признаком volatile, гарантровано возвращает наиболее свежую версию сохраненного в ней значения.*
10. Специальные методы класса Object. Особенности использования методов класса Object.
  > Наконец, переходим к рассмотрению трех методов класса Object, которое завершает описание механизмов поддержки многопоточности в Java.
  >
  > Каждый объект в Java имеет так называемый wait-set, набор потоков исполнения. Любой поток может вызвать метод wait() любого объекта и таким образом попасть в его wait-set. При этом выполнение такого потока приостанавливается до тех пор, пока другой поток не вызовет у точно этого же объекта метод notifyAll(), который пробуждает все потоки из wait-set. Метод notify() пробуждает один, случайно выбранный поток из этого набора. Однако применение этих методов связано с некоторыми особенностями:
  >
  > Особенности использования методов класса Object:
  > - Метод может быть вызван потоком у объекта только после установления блокировки на этот объект. То есть, либо внутри synchronized-блока с ссылкой на этот объект в качестве аргумента, либо обращение к методам должны быть в синхронизированных методах класса самого объекта. 
  > - Потоки, прежде чем приостановить выполнение после вызова метода wait(), снимают все блокировки. 
  > - После вызова освобождающего метода потоки пытаются восстановить ранее снятые блокировки.
11. java.util.concurrent.locks. Lock, ReentrantLock, ReadWriteLock.
  > - Concurrent Collections — набор коллекций, более эффективно работающие в многопоточной среде нежели стандартные универсальные коллекции из java.util пакета, где вместо базовой обертки Collections.synchronizedList() с блокированием доступа ко всей коллекции используются блокировки по сегментам данных или же оптимизируется работа для параллельного чтения данных 
  > - Queues — неблокирующие (направлены на скорость и работу без блокирования потоков) и блокирующие (используются, когда нужно «притормозить» потоки чтения или записи, если не выполнены какие-либо условия, например, очередь пуста или переполнена, или же нет свободного читателя) очереди с поддержкой многопоточности 
  > - Synchronizers — вспомогательные утилиты для синхронизации потоков, которые представляют собой мощное оружие в параллельных вычислениях. 
  > - Executors — содержит в себе отличные фрейморки для создания пулов потоков, планирования работы асинхронных задач с получением результатов 
  > - Locks — представляет собой альтернативные и более гибкие механизмы синхронизации потоков по сравнению с базовыми synchronized(), wait(), notify(), notifyAll()
  > - Atomics — классы с поддержкой атомарных операций над примитивами и ссылками
  > В Java SE 5.0 появился класс java.uti.concurrent.locks.ReentrantLock, конструирующий реентерабельную блокировку, которая может быть испаользована для защиты критичной части кода.
  > 
  > Такая конструкция гарантирует, что только один поток в единицу времени сможет войти в критичный раздел кода. Как только один поток блокирует объект блокировки, никакой другой поток не сможет выполнить оператор lock. Когда другие потоки попытаются это сделать, они будут деактивированы до тех пор, пока первый поток не снимет блокировку с этого объекта. Важно, чтобы операция unlock помещалась в конструкцию finally. Если код критичного раздела сгенерирует исключение, блокировка должна быть снята. В противном случае другие потоки будут заблокированы навсегда.
  >  
  > Блокировка называется реентерабельной, потому что поток может повторно захватывать блокировку, которой он уже владеет. Объект блокировки имеет счетчик блокировок, отслеживающий вложенные вызовы метода lock(). Поток должен вызвать unlock() для каждого вызова lock(), чтобы, в конце концов, снять блокировку.
  >  
  > Поток блокируется навечно, когда он вызывает метод lock() для захвата блокировки, которой владеет другой поток. Поэтому следует быть осторожным, пытаясь захватить блокировку. Метод tryLock() пытается захватить блокировку и возвращает true, если ему это удается. Иначе возвращается false и тогда можно переключить поток на что-нибудь другое.
  >  
  > Пакет java.util.concurrent.locks определяет два класса блокировок – ReentrantLock и ReentrantReadWriteLock. Последний удобен, когда есть много потоков, читающих структуру данных, и поменьше потоков – модифицирующих её. В такой ситуации имеет смысл разрешить разделенный доступ читателям. Конечно, поток-писатель должен по-прежнему иметь исключительный доступ. Ниже описаны шаги, необходимые для использования блокировок чтения/записи.
12. Интерфейсы Callable и Future. 
  > Callable подобен Runnable, но с возвратом значения. Интерфейс Callable является параметризованным типом с единственным общедоступным методом call().
  ```
  public interface Callable <V> {
  V call() throws Exception;
  }
  public interface Future <V> {
  V get();
  void cancel(boolean mayInterrupt);
  boolean isCancelled();
  boolean isDone();
  }
  ```
  > Параметр представляет собой тип возвращаемого значения.
  Future хранит результат вычисления. Можно запустить вычисление, предоставив кому-либо объект Future и забыть о нём. Владелец объекта Future может получить результат, когда он будет готов. Интерфейс Future имеет следующие методы:
  > 
  > Вызов метода get() устанавливает блокировку до тех пор, пока не завершится вычисление или истечения указанного времени.
  >
  > Можно прервать вычисление, вызвав метод cancel(). Если вычисление не стартовало, оно отменяется и уже не будет запущено. Если вычисление уже идёт, оно прерывается в случае равенства true параметра mayInterrupt.
  > - isCancelled() возвращает true, если задача была отменена до её завершения. 
  > - isDone() возвращает false, если вычисление продолжается, и true –если оно завершено или отменено.

13. Интерфейсы Executor, ExecutorService, ScheduledExecutorService.
  > Пакет java.util.concurrent содержит три интерфейса исполнителей:
  >  
  > **Executor** – простой интерфейс, поддерживающий запуск новой задачи. 
  >  
  > **ExecutorService**, расширяющий Executor, добавляет возможности по управлению жизненным циклом отдельных задач и самого исполнителя. 
  >
  > **ScheduledExecutorService**, расширяющий ExecutorService, поддерживает периодическое выполнение задач или их запуск в будущем. Это обощение java.util.Timer, позволяющее создавать пул потоков. 
  >  
  > Обычно переменные-ссылки на объекты исполнителей объявляются одного из этих трех интерфейсных типов без указания конкретного имени класса исполнителя. 
  >  
  > Интерфейс Executor предоставляет единственный метод, execute(), разработанный для замены общего подхода создания потоков. Если r является Runnable объектом и e является Executor объектом, вы можете заменить
  **(new Thread(r)).start();**
  на
  **e.execute(r);**
  > Однако определение execute() менее специфично. В Java 1.4 создается новый поток и запускается. В зависимости от реализации Executor, execute() может сделать то же самое, но более вероятно использует существующий рабочий поток для запуска r или размещения r в очереди ожидания доступного рабочего потока. 
  > 
  > Реализации исполнителей в java.util.concurrent спроектированы так, чтобы в полной мере использовать более продвинутые ExecutorService и ScheduledExecutorService интерфейсы, хотя они также работают с базовым интерфейсом Executor.
14. Пул потоков. Executors.
> Создание нового потока – довольно дорогостоящая (в плане времени и ресурсов) операция, поскольку включает взаимодействие с операционной системой. Если ваша программа создает большое количество кратковременных потоков, то имеет смысл использовать пул потоков. Пул потоков содержит множество простаивающих потоков, готовых к запуску. Вы помещаете Runnable в пул, и один из потоков вызывает его метод run(). Когда метод run() завершается, поток не уничтожается и остается в пуле в готовности обслужить новый запрос.
>
> Другая причина использования пула потоков – необходимость ограничить количество конкурирующих потоков. Создание огромного числа потоков может пагубно отобразиться на производительности. Если у вас есть алгоритм, создающий большое количество потоков, то вам следует установить «фиксированный» пул потоков, который ограничит общее количество конкурирующих потоков. Класс Executors имеет следующие статические методы для конструирования пулов потоков:
> - **newCachedThreadPool()** – создаёт пул потоков, выполняющий каждую задачу немедленно, используя существующий простаивающий поток, если он доступен, либо создавая новый в противном случае.
> - **newFixedThreadPool()** – создаёт пул потоков фиксированного размера. Если количество задач превышает количество простаивающих потоков, то лишние ставятся в очередь, чтобы быть запущенными, когда завершатся текущие выполняющиеся задачи.
> - **newSingleThreadExecutor()** – создает пул размером в 1 поток. Единственый поток выполняет все отправленные ему задачи – одну за другой. Перечисленные три метода возвращают объект класса ThreadPoolExecutor, реализующий интерфейс ExecutorService.
>
> Можно послать Runnable или Callable объекту ExecutorService одним из следующих методов:
>
> Future <?> submit (Runnable task)
>
> Future <T> submit (Runnable task, T result)
>
> Future <T> submit (Callable <T> task)
> 
> Пул запустит установленную таким образом задачу при первой возможности. Когда вызывется submit(), вы получаете объект Future, который можно использовать для опроса состояния задачи. Первый метод submit() вернет Future<?>, этот объект можно использовать для вызова isDone(), cancel() или isCancelled().
>
> get() по завершении вернёт просто null.  Вторая версия submit() также принимает Runnable, а метод get() объекта Future вернет по завершении заданный объект result. Третья версия принимает Callable, а возвращенный Future получает результат вычисления по его готовности. 
> 
> Завершив работу с пулом потоков, вызывайте shutdown(). Этот метод инициирует последовательность выключения пула. После этого объект пула не принимает новых задач. Когда все задачи завершены, потоки в пуле уничтожаются. В качестве альтернативы можно вызвать shutdownNow(). В этом случае пул отменяет все задачи, которые ещё не стартовали, и пытается прервать работающие потоки. Итак, чтобы использовать пул потоков, надо:
> 1. Вызвать  статический метод newCachedThreadPool() или newFixedThreadPool() класса Executors. 
> 2. Вызвать submit() для установки объектов Runnable или Callable. 
> 3. Если хотите иметь возможность прерывать задачу, или если устанавливаете объекты Callable, обратитесь к возвращенным объектам Future. 
> 4. Вызвать shutdown(), когда больше не собираетесь запускать новых задач.
**newScheduledThreadPool(int threads)** – возвращает пул потоков, использующих заданное их количество для планирования запуска задач.
**newSingleThreadScheduledExecutor()** – возвращает исполнитель, планирующий запуск задач последовательно в одном потоке.
>
> Эти методы возвращают объекы, реализующие интерфейс ScheduledExecutorService.
```
class NetworkService implements Runnable {
private final ServerSocket serverSocket;
private final ExecutorService pool;
public NetworkService(int port, int poolSize) throws IOException {
serverSocket = new ServerSocket(port);
pool = Executors.newFixedThreadPool(poolSize);
}
public void run() {
try {
for (;;) {
pool.execute(new Handler(serverSocket.accept()));
}
} catch (IOException ex) { pool.shutdown(); }
}
}
class Handler implements Runnable {
private final Socket socket;
Handler(Socket socket) { this.socket = socket; }
public void run() { … }
} 
```